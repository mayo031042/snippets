{
    "pSHOW": {
        "prefix": "P??",
        "body": [
            "// p??: print this message",
            "// tnap: (?:)",
            "// abso: std::abs",
            "// nn: col ans",
            "// mm: mod",
            "// ll,ss,dd,vv,ww,qq: type",
            "// ctt,cct,cii,cci,cll,ccl,css,cvt,cvvt: cin type",
            "// cop,col,pol: cout type",
            "// vmin: vector[all]--;",
            "// pRUNL: run length encoding",
            "// mmr: memory",
            "// pSAND: sand",
            "// pGCD: gcd",
            "// pPOW<-mm : power",
            "// pNCK<-mm : nck",
            "// pRNG: lx, ly, rx, ry",
            "// pIMS1: 1dim imosu hou",
            "// pIMS2: 2dim imosu hou",
            "// pGG: edge",
            "// pFF: graph",
            "// pFFS: graphs",
            "// pDIJK<-pFF : Dijkstra",
            "// pBELF<-pFF : BellmanFord",
            "// pLCA<-pFF : Lowest Common Ancestor",
            "// pPRIM<-pFF : Prim",
            "// pSCC<-pFF : Strongly Connected Components",
            "// pTPS<-pFF : topological sort",
            "// pANGLE: rad & deg",
            "// pROTATE: 点の回転",
            "// pUF: union find",
            "// pDAY: 日付計算",
            "// pNTT: 進数表記変換",
            "// pCLCL: 周期性処理",
            "// pBINS: binary search",
            "// pRESTORE: sort and restore",
            "// pMATRIX: matrix",
            "// pAFFINE<-pMATRIX : Affine Transform",
            "// double x <  y  ->  x <  y - eps 厳しく",
            "// double x <= y  ->  x <= y + eps 甘く",
        ]
    },
    "p": {
        "prefix": "p",
        "body": [
            "#include <iostream>",
            "#include <fstream>",
            "#include <vector>",
            "#include <string>",
            "#include <algorithm>",
            "#include <queue>",
            "#include <map>",
            "#include <set>",
            "#include <bitset>",
            "#include <cmath>",
            "#include <cassert>",
            "// #include <atcoder/all>",
            "using namespace std;",
            "template <class T>",
            "using minpq = priority_queue<T, vector<T>, greater<T>>;",
            "const int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};",
            "const int dy[8] = {0, 1, 0, -1, 1, -1, -1, 1};",
            "#define pii pair<int, int>",
            "#define pll pair<long long int, long long int>",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define sz(x) int(x.size())",
            "#define yn(x) cout << ((x) ? \"Yes\" : \"No\") << endl",
            "template <class T>",
            "T chmax(T &x, const T &y)",
            "{",
            "    return x = max(x, y);",
            "}",
            "template <class T>",
            "T chmin(T &x, const T &y)",
            "{",
            "    return x = min(x, y);",
            "}",
            "template <class T>",
            "void align(T &x, T &y)",
            "{",
            "    if (x > y)",
            "    {",
            "        swap(x, y);",
            "    }",
            "}",
            "",
            "int main()",
            "{",
            "\t$0",
            "}",
        ]
    },
    "ternary operator": {
        "prefix": "tnap",
        "body": [
            "(($1) ? $2 : $3)$0",
        ]
    },
    "pCNTMAP": {
        "prefix": "pCNTMAP",
        "body": [
            "template <typename T>",
            "class cntmap",
            "{",
            "public:",
            "    map<T, int> mp;",
            "    cntmap() {}",
            "    inline int add(T x)",
            "    {",
            "        return ++mp[x];",
            "    }",
            "    inline void pop(T x)",
            "    {",
            "        if (--mp[x] == 0)",
            "        {",
            "            mp.erase(x);",
            "        }",
            "    }",
            "    // 値が存在していることに注意",
            "    inline T maxV()",
            "    {",
            "        return mp.rbegin()->first;",
            "    }",
            "    // 値が存在していることに注意",
            "    inline T minV()",
            "    {",
            "        return mp.begin()->first;",
            "    }",
            "    int size()",
            "    {",
            "        return sz(mp);",
            "    }",
            "",
            "    inline int &operator[](int i)",
            "    {",
            "        return mp.at(i);",
            "    }",
            "};\n",
        ]
    },
    "nn": {
        "prefix": "nn",
        "body": [
            "cout << ans << endl;\n$0",
        ]
    },
    "ll": {
        "prefix": "ll",
        "body": [
            "long long $0",
        ]
    },
    "ss": {
        "prefix": "ss",
        "body": [
            "string $0",
        ]
    },
    "dd": {
        "prefix": "dd",
        "body": [
            "double $0",
        ]
    },
    "ww": {
        "prefix": "ww",
        "body": [
            "vector<vector<$1>> $2($3, vector<$1>($4, $5));\n",
        ]
    },
    "vv": {
        "prefix": "vv",
        "body": [
            "vector<$0>",
        ]
    },
    "qq": {
        "prefix": "qq",
        "body": [
            "queue<$0>",
        ]
    },
    "ctt": {
        "prefix": "ctt",
        "body": [
            "$1 $2;",
            "cin >> $2;\n",
        ]
    },
    "cct": {
        "prefix": "cct",
        "body": [
            "$1 $2, $3;",
            "cin >> $2 >> $3;\n",
        ]
    },
    "cii": {
        "prefix": "cii",
        "body": [
            "int $1;",
            "cin >> $1;\n",
        ]
    },
    "cci": {
        "prefix": "cci",
        "body": [
            "int $1, $2;",
            "cin >> $1 >> $2;\n",
        ]
    },
    "cll": {
        "prefix": "cll",
        "body": [
            "long long int $1;",
            "cin >> $1;\n",
        ]
    },
    "ccl": {
        "prefix": "ccl",
        "body": [
            "long long int $1, $2;",
            "cin >> $1 >> $2;\n",
        ]
    },
    "css": {
        "prefix": "css",
        "body": [
            "string $1;",
            "cin >> $1;\n",
        ]
    },
    "cvt": {
        "prefix": "cvt",
        "body": [
            "vector<$1> $2($3);",
            "for (int i = 0; i < $3; i++)",
            "{",
            "\tcin >> $2[i];",
            "}\n",
        ]
    },
    "cvvt": {
        "prefix": "cvvt",
        "body": [
            "vector<vector<$1>> $2($3, vector<$1>($4));",
            "for (int i = 0; i < $3; i++)",
            "{",
            "\tfor (int j = 0; j < $4; j++)",
            "\t{",
            "\t\tcin >> $2[i][j];",
            "\t}",
            "}\n",
        ]
    },
    "cop": {
        "prefix": "cop",
        "body": [
            "cout << $1 << \" \";",
            "$0cout << endl;",
        ]
    },
    "col": {
        "prefix": "col",
        "body": [
            "std::cout << $1 << std::endl;\n",
        ]
    },
    "pol": {
        "prefix": "pol",
        "body": [
            "printf(\"%.9lf\\n\", $1);\n",
        ]
    },
    "mm": {
        "prefix": "mm",
        "body": [
            "constexpr long long int P = ${1|1e9 + 7,998244353|};",
        ]
    },
    "abso": {
        "prefix": "abso",
        "body": [
            "std::abs($1)$0",
        ]
    },
    "pCLASS": {
        "prefix": "pCLASS",
        "body": [
            "template <typename T>",
            "class $1",
            "{",
            "public:\n\t$0",
            "    $1(){}",
            "    inline int &operator[](int i)",
            "\t{\n\t}",
            "};",
        ]
    },
    "rrepite": {
        "prefix": "rrepite",
        "body": [
            "for (auto $1 = $2.rbegin(); $1 != $2.rend(); $1++)",
            "{ // rrepite",
            "\t$0",
            "} // rrepite\n",
        ]
    },
    "repite": {
        "prefix": "repite",
        "body": [
            "for (auto $1 = $2.begin(); $1 != $2.end(); $1++)",
            "{",
            "\t$0",
            "}\n",
        ]
    },
    "rep": {
        "prefix": "rep",
        "body": [
            "for (int $1 = $2; $1 < $3; $1++)",
            "{",
            "\t$0",
            "}\n",
        ]
    },
    "rrep": {
        "prefix": "rrep",
        "body": [
            "// reverse",
            "for (int $1 = $3 - 1; $1 >= $2; $1--)",
            "{",
            "\t$0",
            "}\n",
        ]
    },
    "dll": {
        "prefix": "dll",
        "body": [
            "do",
            "{",
            "    $0",
            "} while ($1);\n",
        ]
    },
    "wll": {
        "prefix": "wll",
        "body": [
            "while ($1)",
            "{",
            "    $0",
            "}\n",
        ]
    },
    "all": {
        "prefix": "all",
        "body": [
            "$1.begin(), $1.end()$0"
        ]
    },
    "rall": {
        "prefix": "rall",
        "body": [
            "$1.rbegin(), $1.rend()$0"
        ]
    },
    "rpt": {
        "prefix": "rpt",
        "body": [
            "cout << $1 << endl;",
            "return 0;\n$0"
        ]
    },
    "ret": {
        "prefix": "ret",
        "body": [
            "return $1;\n$0"
        ]
    },
    "vmin": {
        "prefix": "vmin",
        "body": [
            "for (int i = 0; i < $2; i++)",
            "{",
            "\t$1[i]--;",
            "}\n",
        ]
    },
    "ato": {
        "prefix": "ato",
        "body": [
            "for (auto &$1 : $2)",
            "{",
            "\t$0",
            "}\n",
        ]
    },
    "atf": {
        "prefix": "atf",
        "body": [
            "auto $2 = [&]($3) -> $1",
            "{",
            "    $0",
            "};\n",
        ]
    },
    "srt": {
        "prefix": "srt",
        "body": [
            "sort($1.begin(), $1.end());\n"
        ]
    },
    "rsrt": {
        "prefix": "rsrt",
        "body": [
            "sort($1.rbegin(), $1.rend());\n"
        ]
    },
    "mycinfile": {
        "prefix": "mycinfile",
        "body": [
            "class file",
            "{",
            "public:",
            "    vector<string> v;",
            "    file(string file_path)",
            "    {",
            "        ifstream ifs(file_path);",
            "        string s;",
            "        while (getline(ifs, s))",
            "        {",
            "            v.push_back(s);",
            "        }",
            "        ifs.close();",
            "    }",
            "    inline string &operator[](int i)",
            "    {",
            "        return v[i];",
            "    }",
            "    std::__1::vector<std::__1::string>::iterator begin()",
            "    {",
            "        return v.begin();",
            "    }",
            "    std::__1::vector<std::__1::string>::iterator end()",
            "    {",
            "        return v.end();",
            "    }",
            "};\n",
        ]
    },
    "mycin": {
        "prefix": "mycin",
        "body": [
            "string input_txt = \"mycin.txt\";",
            "ifstream ifs(input_txt);",
            "cin.rdbuf(ifs.rdbuf());\n",
        ]
    },
    "pOPER": {
        "prefix": "pOPER",
        "body": [
            "bool operator>(const $1 &L$1, const $1 R$1) { return L$1.$2 > R$1.$2; }\n$0",
        ]
    },
    "pRUNL": {
        "prefix": "pRUNL",
        "body": [
            "template <typename T>",
            "class runl",
            "{",
            "public:",
            "    vector<pair<T, int>> v;",
            "    template <class U>",
            "    auto calc(U ite, int tms)",
            "    {",
            "        auto pre = ite;",
            "        int cnt = 1;",
            "        while (--tms)",
            "        {",
            "            ite++;",
            "            if (*pre != *ite)",
            "            {",
            "                v.emplace_back(*pre, cnt);",
            "                pre = ite;",
            "                cnt = 1;",
            "                continue;",
            "            }",
            "            cnt++;",
            "        }",
            "        v.emplace_back(*pre, cnt);",
            "    };",
            "",
            "    runl(string &bs)",
            "    {",
            "        calc(bs.begin(), sz(bs));",
            "    }",
            "    runl(vector<T> &bs)",
            "    {",
            "        calc(bs.begin(), sz(bs));",
            "    }",
            "    inline pair<T, int> &operator[](int i)",
            "    {",
            "        return v.at(i);",
            "    }",
            "    int size()",
            "    {",
            "        return sz(v);",
            "    }",
            "};\n",
        ]
    },
    "pMMR": {
        "prefix": "pMMR",
        "body": [
            "template <typename T>",
            "class mmr",
            "{",
            "public:",
            "    map<T, long long> mp;",
            "    int size()",
            "    {",
            "        return sz(mp);",
            "    }",
            "    inline bool operator()(T x)",
            "    {",
            "        return (mp.count(x) != 0);",
            "    }",
            "    inline long long &operator[](T x)",
            "    {",
            "        return mp[x];",
            "    }",
            "};\n",
        ]
    },
    "pSAND": {
        "prefix": "pSAND",
        "body": [
            "template <typename T>",
            "class sand",
            "{",
            "public:",
            "    vector<T> v;",
            "    constexpr static int buf = 1;",
            "    int n;",
            "",
            "    sand(int N, T base) : n(N + buf * 2)",
            "    {",
            "        v.resize(n, base);",
            "    }",
            "    inline T &operator[](int i)",
            "    {",
            "        return v.at(i + buf);",
            "    }",
            "};",
        ]
    },
    "next_combination": {
        "prefix": "next_combination",
        "body": [
            "template <typename Iterator>",
            "inline bool next_combination(const Iterator first, Iterator k, const Iterator last)",
            "{",
            "    /* Credits: Thomas Draper */",
            "    if ((first == last) || (first == k) || (last == k))",
            "    {",
            "        return false;",
            "    }",
            "    Iterator itr1 = first;",
            "    Iterator itr2 = last;",
            "    ++itr1;",
            "    if (last == itr1)",
            "    {",
            "        return false;",
            "    }",
            "    itr1 = last;",
            "    --itr1;",
            "    itr1 = k;",
            "    --itr2;",
            "    while (first != itr1)",
            "    {",
            "        if (*--itr1 < *itr2)",
            "        {",
            "            Iterator j = k;",
            "            while (!(*itr1 < *j))",
            "            {",
            "                ++j;",
            "            }",
            "            iter_swap(itr1, j);",
            "            ++itr1;",
            "            ++j;",
            "            itr2 = k;",
            "            rotate(itr1, j, last);",
            "            while (last != j)",
            "            {",
            "                ++j;",
            "                ++itr2;",
            "            }",
            "            rotate(k, itr2, last);",
            "            return true;",
            "        }",
            "    }",
            "    rotate(first, k, last);",
            "    return false;",
            "}",
            "do {} while (next_combination($1.begin(), $1.begin() + $2, $1.end()));",
            "",
        ]
    },
    // Algorithm
    "pIMS": {
        "prefix": "pIMS",
        "body": [
            "// 加算したい範囲を指定する [x~y)",
            "class IMS",
            "{",
            "    void calc()",
            "    {",
            "        for (int i = 1; i < n; i++)",
            "        {",
            "            v[i] += v[i - 1];",
            "        }",
            "",
            "        is_calced = true;",
            "    }",
            "",
            "public:",
            "    int n;",
            "    bool is_calced = false;",
            "    vector<long long int> v;",
            "    IMS(int N) : n(N + 3)",
            "    {",
            "        v.resize(n, 0);",
            "    }",
            "",
            "    // 0_indexed, [l ~ r) += x;",
            "    void plot(long long int x, int l, int r)",
            "    {",
            "        l++;",
            "        r++;",
            "",
            "        v[l] += x;",
            "        v[r] -= x;",
            "",
            "        is_calced = false;",
            "    }",
            "    void plot(long long int x, int l)",
            "    {",
            "        plot(x, l, n - 2);",
            "    }",
            "",
            "    long long int range(int l, int r)",
            "    {",
            "        if (is_calced == false)",
            "        {",
            "            calc();",
            "        }",
            "        chmin(r, n - 2);",
            "        return v[r] - v[l];",
            "    }",
            "    long long int range(int l)",
            "    {",
            "        return range(l, n - 2);",
            "    }",
            "};\n",
        ]
    },
    "pIMS2": {
        "prefix": "pIMS2",
        "body": [
            "// 加算したい範囲を指定する [x~y)",
            "class IMS2",
            "{",
            "    void calc()",
            "    {",
            "        for (int i = 0; i < h; i++)",
            "        {",
            "            for (int j = 1; j < w; j++)",
            "            {",
            "                v[i][j] += v[i][j - 1];",
            "            }",
            "        }",
            "        for (int j = 0; j < w; j++)",
            "        {",
            "            for (int i = 1; i < h; i++)",
            "            {",
            "                v[i][j] += v[i - 1][j];",
            "            }",
            "        }",
            "",
            "        is_calced = true;",
            "    }",
            "",
            "public:",
            "    int h, w;",
            "    bool is_calced = false;",
            "    vector<vector<long long int>> v;",
            "    IMS2(int H, int W)",
            "    {",
            "        h = H + 3;",
            "        w = W + 3;",
            "        v.resize(h, vector<long long int>(w, 0));",
            "    }",
            "",
            "    // 0_indexed, [(lx,ly) ~ (rx,ry)) += x;",
            "    void plot(long long int x, int lx, int ly, int rx, int ry)",
            "    {",
            "        chmin(rx, h - 2);",
            "        chmin(ry, w - 2);",
            "        lx++;",
            "        ly++;",
            "        rx++;",
            "        ry++;",
            "",
            "        v[lx][ly] += x;",
            "        v[lx][ry] -= x;",
            "        v[rx][ly] -= x;",
            "        v[rx][ry] += x;",
            "",
            "        is_calced = false;",
            "    }",
            "    void plot(long long int x, int lx, int ly)",
            "    {",
            "        plot(x, lx, ly, h - 2, w - 2);",
            "    }",
            "",
            "    long long int range(int lx, int ly, int rx, int ry)",
            "    {",
            "        if (is_calced == false)",
            "        {",
            "            calc();",
            "        }",
            "        chmin(rx, h - 2);",
            "        chmin(ry, w - 2);",
            "        return v[rx][ry] - v[lx][ry] - v[rx][ly] + v[lx][ly];",
            "    }",
            "    long long int range(int lx, int ly)",
            "    {",
            "        return range(lx, ly, h - 2, w - 2);",
            "    }",
            "};\n",
        ]
    },
    "pBINS": {
        "prefix": "pBINS",
        "body": [
            "class BINS",
            "{",
            "public:",
            "    BINS() {}",
            "    template <typename _Goodcondi>",
            "    long long operator()(long long ok, long long ng, _Goodcondi __condi)",
            "    {",
            "        while (std::abs(ok - ng) > 1)",
            "        {",
            "            long long hf = (ok + ng) / 2;",
            "            if (__condi(hf))",
            "            {",
            "                ok = hf;",
            "            }",
            "            else",
            "            {",
            "                ng = hf;",
            "            }",
            "        }",
            "        return ok;",
            "    }",
            "};",
            "BINS bs;\n",
        ]
    },
    "pGCD": {
        "prefix": "pGCD",
        "body": [
            "class gcd",
            "{",
            "    using T = long long int;",
            "    T _gcd(T x, T y)",
            "    {",
            "        return (y ? _gcd(y, x % y) : x);",
            "    }",
            "",
            "public:",
            "    T operator()(T first)",
            "    {",
            "        return first;",
            "    }",
            "    template <class... Rest>",
            "    T operator()(T first, Rest... rest)",
            "    {",
            "        return _gcd(first, this->operator()(rest...));",
            "    }",
            "    T lcm(T first)",
            "    {",
            "        return first;",
            "    }",
            "    template <class... Rest>",
            "    T lcm(T first, Rest... rest)",
            "    {",
            "        T res = lcm(rest...);",
            "        return first / _gcd(first, res) * res;",
            "    }",
            "};",
            "gcd GCD;\n",
        ]
    },
    "pMODINV": {
        "prefix": "pMODINV",
        "body": [
            "long long modinv(long long x, long long mod)",
            "{",
            "    long long y = mod, u = 1, v = 0;",
            "    while (y)",
            "    {",
            "        long long t = x / y;",
            "        x -= t * y;",
            "        swap(x, y);",
            "        u -= t * v;",
            "        swap(u, v);",
            "    }",
            "",
            "    return (((u %= mod) < 0) ? u + mod : u);",
            "}\n",
        ]
    },
    "pPWR": {
        "prefix": "pPWR",
        "body": [
            "long long int pwr(long long int x, long long int n = P - 2)",
            "{",
            "    if (n & 1)",
            "    {",
            "        return pwr(x, n - 1) * x % P;",
            "    }",
            "    if (!n)",
            "    {",
            "        return 1;",
            "    }",
            "    long long int ans = pwr(x, n / 2);",
            "    return ans * ans % P;",
            "}\n",
        ],
        "description": "mm"
    },
    "pNCK": {
        "prefix": "pNCK",
        "body": [
            "class nck",
            "{",
            "public:",
            "    using T = long long int;",
            "    T max_size = 1e6 + 5;",
            "    vector<T> fac, fac_inv, inv;",
            "    void vec_resize(vector<T> &v)",
            "    {",
            "        v.resize(max_size);",
            "        v[0] = v[1] = 1;",
            "    }",
            "    nck()",
            "    {",
            "        vec_resize(fac);",
            "        vec_resize(fac_inv);",
            "        vec_resize(inv);",
            "        for (T i = 2; i < max_size; i++)",
            "        {",
            "            fac[i] = fac[i - 1] * i % P;",
            "            inv[i] = P - inv[P % i] * (P / i) % P;",
            "            fac_inv[i] = fac_inv[i - 1] * inv[i] % P;",
            "        }",
            "    }",
            "",
            "    T operator()(T n, T k)",
            "    {",
            "        if (n < k || n < 0 || k < 0)",
            "        {",
            "            return 0;",
            "        }",
            "        return fac[n] * fac_inv[n - k] % P * fac_inv[k] % P;",
            "    }",
            "};",
            "nck NCK;\n",
        ],
        "description": "mm"
    },
    "pGG": {
        "prefix": "pGG",
        "body": [
            "class gg",
            "{",
            "public:",
            "    int f, t;",
            "    long long int l = 1;",
            "    gg() {}",
            "    gg(int F, int T, long long L = 1) : f(F), t(T), l(L) {}",
            "    gg &ft()",
            "    {",
            "        cin >> f >> t;",
            "        return *this;",
            "    }",
            "    gg &ftl()",
            "    {",
            "        cin >> f >> t >> l;",
            "        return *this;",
            "    }",
            "    gg &minus()",
            "    {",
            "        f--;",
            "        t--;",
            "        return *this;",
            "    }",
            "    gg operator()()",
            "    {",
            "        return gg(t, f, l);",
            "    }",
            "    bool operator<(const gg &g) const { return this->l < g.l; }",
            "    bool operator>(const gg &g) const { return this->l > g.l; }",
            "};\n",
        ]
    },
    "pFF": {
        "prefix": "pFF",
        "body": [
            "class gg",
            "{",
            "public:",
            "    int f, t;",
            "    long long int l = 1;",
            "    gg() {}",
            "    gg(int F, int T, long long L = 1) : f(F), t(T), l(L) {}",
            "    gg &ft()",
            "    {",
            "        cin >> f >> t;",
            "        return *this;",
            "    }",
            "    gg &ftl()",
            "    {",
            "        cin >> f >> t >> l;",
            "        return *this;",
            "    }",
            "    gg &minus()",
            "    {",
            "        f--;",
            "        t--;",
            "        return *this;",
            "    }",
            "    gg operator()()",
            "    {",
            "        return gg(t, f, l);",
            "    }",
            "    bool operator<(const gg &g) const { return this->l < g.l; }",
            "    bool operator>(const gg &g) const { return this->l > g.l; }",
            "};",
            "",
            "class ff",
            "{",
            "public:",
            "    int edz = 0;",
            "    vector<vector<gg>> v;",
            "    ff() {}",
            "    ff(int n) : v(n) {}",
            "    void reverse(ff &f)",
            "    {",
            "        int n = sz(f);",
            "        v.resize(n);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            for (auto &g : f[i])",
            "            {",
            "                this->operator()(g());",
            "            }",
            "        }",
            "    }",
            "",
            "    int size()",
            "    {",
            "        return sz(v);",
            "    }",
            "    void resize(int sz)",
            "    {",
            "        v.resize(sz);",
            "    }",
            "",
            "    inline int operator()(const gg &g)",
            "    {",
            "        v[g.f].push_back(g);",
            "        return ++edz;",
            "    }",
            "    inline vector<gg> &operator[](int i)",
            "    {",
            "        return v.at(i);",
            "    }",
            "    auto begin()",
            "    {",
            "        return v.begin();",
            "    }",
            "    auto end()",
            "    {",
            "        return v.end();",
            "    }",
            "};\n",
        ],
        "description": "pGG"
    },
    "pFFS": {
        "prefix": "pFFS",
        "body": [
            "class ffs",
            "{",
            "    class UF",
            "    {",
            "    public:",
            "        int n;",
            "        vector<int> par;",
            "        int root(int x)",
            "        {",
            "            return ((par[x] < 0) ? x : par[x] = root(par[x]));",
            "        }",
            "        void set(int sz)",
            "        {",
            "            n = sz;",
            "            par.resize(sz, -1);",
            "        }",
            "        int size(int x)",
            "        {",
            "            return -par.at(root(x));",
            "        }",
            "        int size()",
            "        {",
            "            return n;",
            "        }",
            "        void unite(int x, int y)",
            "        {",
            "            x = root(x);",
            "            y = root(y);",
            "            if (x == y)",
            "            {",
            "                return;",
            "            }",
            "            align(x, y);",
            "            par[x] += par[y];",
            "            par[y] = x;",
            "            n--;",
            "        }",
            "        int operator[](int x)",
            "        {",
            "            return root(x);",
            "        }",
            "    };",
            "    UF uf;",
            "    vector<int> order;",
            "    // root -> x,,,(vector)",
            "    map<int, vector<int>> bind;",
            "    // root -> vers(0index)",
            "    map<int, ff> mp;",
            "",
            "public:",
            "    void calc(ff &f)",
            "    {",
            "        int n = sz(f);",
            "        uf.set(n);",
            "        for (auto &fx : f)",
            "        {",
            "            for (auto &g : fx)",
            "            {",
            "                uf.unite(g.f, g.t);",
            "            }",
            "        }",
            "",
            "        order.resize(n, 0);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            int rt = uf[i];",
            "            if (i == rt)",
            "            {",
            "                bind[rt].reserve(uf.size(rt));",
            "            }",
            "            else",
            "            {",
            "                order[i] = order[*bind[rt].rbegin()] + 1;",
            "            }",
            "            bind[rt].push_back(i);",
            "        }",
            "        for (auto &pr : bind)",
            "        {",
            "            int rt = pr.first;",
            "            mp[rt].resize(uf.size(rt));",
            "            auto &vers = pr.second;",
            "",
            "            for (auto &x : vers)",
            "            {",
            "                int odrx = order[x];",
            "                for (auto &g : f[x])",
            "                {",
            "                    mp[rt](gg(odrx, order[g.t], g.l));",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    ffs() {}",
            "    ffs(ff &f)",
            "    {",
            "        calc(f);",
            "    }",
            "",
            "    int size()",
            "    {",
            "        return sz(mp);",
            "    }",
            "    bool is_same(int x, int y)",
            "    {",
            "        return uf[x] == uf[y];",
            "    }",
            "    int root(int x)",
            "    {",
            "        return uf[x];",
            "    }",
            "    inline ff &operator[](int rt)",
            "    {",
            "        return mp.at(rt);",
            "    }",
            "    auto begin()",
            "    {",
            "        return mp.begin();",
            "    }",
            "    auto end()",
            "    {",
            "        return mp.end();",
            "    }",
            "",
            "    // 指定された頂点x がfs 内のどこにマップされたかを返す",
            "    // x -> fs[pr.first][pr.second]",
            "    pii specify(int x)",
            "    {",
            "        return pii(uf[x], order[x]);",
            "    }",
            "    // fs[rt][num]が指す元のグラフの頂点番号を返す",
            "    int decrypt(int rt, int num)",
            "    {",
            "        return bind.at(rt).at(num);",
            "    }",
            "    int decrypt(pii &pr)",
            "    {",
            "        return decrypt(pr.first, pr.second);",
            "    }",
            "};\n",
        ],
        "description": "pFF"
    },
    "pDIJK": {
        "prefix": "pDIJK",
        "body": [
            "class DIJK",
            "{",
            "public:",
            "    long long int inf = (1ll << 60);",
            "    int stt;",
            "    vector<long long int> dist;",
            "    vector<int> past;",
            "    void calc(ff &f, int STT = 0)",
            "    {",
            "        dist.resize(sz(f), inf);",
            "        past.resize(sz(f), -1);",
            "        stt = STT;",
            "        dist[stt] = 0;",
            "",
            "        minpq<gg> q;",
            "        for (gg &g : f[stt])",
            "        {",
            "            q.push(g);",
            "        }",
            "",
            "        while (!q.empty())",
            "        {",
            "            gg g = q.top();",
            "            q.pop();",
            "",
            "            if (dist[g.t] > dist[g.f] + g.l)",
            "            {",
            "                dist[g.t] = dist[g.f] + g.l;",
            "                past[g.t] = g.f;",
            "",
            "                for (gg &nxt : f[g.t])",
            "                {",
            "                    if (dist[nxt.t] > dist[nxt.f] + nxt.l)",
            "                    {",
            "                        q.push(nxt);",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    DIJK() {}",
            "    DIJK(ff &f, int STT = 0)",
            "    {",
            "        calc(f, STT);",
            "    }",
            "",
            "    vector<int> way_to(int tgt)",
            "    {",
            "        vector<int> way;",
            "        if (!this->is_inf(tgt))",
            "        {",
            "            for (int i = tgt; i != -1; i = past[i])",
            "            {",
            "                way.push_back(i);",
            "            }",
            "            reverse(way.begin(), way.end());",
            "        }",
            "        return way;",
            "    }",
            "",
            "    bool is_inf(int i)",
            "    {",
            "        return (dist.at(i) == inf);",
            "    }",
            "    long long int operator[](int i)",
            "    {",
            "        return dist.at(i);",
            "    }",
            "};\n",
        ]
    },
    "pBELF": {
        "prefix": "pBELF",
        "body": [
            "class BELF",
            "{",
            "    vector<long long int> dist;",
            "    vector<int> past;",
            "",
            "    bool build_dist(ff &f)",
            "    {",
            "        bool changed = false;",
            "        for (int rp = 0; rp < sz(f); rp++)",
            "        {",
            "            changed = false;",
            "",
            "            for (int i = 0; i < sz(f); i++)",
            "            {",
            "                for (auto &g : f[i])",
            "                {",
            "                    if (dist[g.f] == inf)",
            "                    {",
            "                        continue;",
            "                    }",
            "",
            "                    long long int d = dist[g.f] + g.l;",
            "                    if (d < dist[g.t])",
            "                    {",
            "                        changed = true;",
            "",
            "                        if (has_negative_circuit)",
            "                        {",
            "                            dist[g.t] = -inf;",
            "                        }",
            "                        else",
            "                        {",
            "                            dist[g.t] = d;",
            "                            past[g.t] = g.f;",
            "                        }",
            "                    }",
            "                }",
            "            }",
            "",
            "            if (!changed)",
            "            {",
            "                break;",
            "            }",
            "        }",
            "",
            "        return changed;",
            "    }",
            "",
            "public:",
            "    void calc(ff &f, int stt = 0)",
            "    {",
            "        past.resize(sz(f), -1);",
            "        dist.resize(sz(f), inf);",
            "        dist[stt] = 0;",
            "",
            "        has_negative_circuit = build_dist(f);",
            "        if (has_negative_circuit)",
            "        {",
            "            build_dist(f);",
            "        }",
            "    }",
            "",
            "    long long int inf = (1ll << 60);",
            "    int stt;",
            "    bool has_negative_circuit = false;",
            "",
            "    BELF() {}",
            "    BELF(ff &f, int stt = 0)",
            "    {",
            "        calc(f, stt);",
            "    }",
            "",
            "    vector<int> way_to(int tgt)",
            "    {",
            "        vector<int> way;",
            "        if (!this->is_inf(tgt))",
            "        {",
            "            for (int i = tgt; i != -1; i = past[i])",
            "            {",
            "                way.push_back(i);",
            "            }",
            "            reverse(way.begin(), way.end());",
            "        }",
            "        return way;",
            "    }",
            "    // 到達不可能または負の閉路の影響を受ける場合true",
            "    bool is_inf(int i)",
            "    {",
            "        return (std::abs(dist.at(i)) == inf);",
            "    }",
            "    long long int operator[](int i)",
            "    {",
            "        return dist.at(i);",
            "    }",
            "};\n",
        ],
        "description": "pFF"
    },
    "pLCA": {
        "prefix": "pLCA",
        "body": [
            "class LCA",
            "{",
            "public:",
            "    // par[i][x] == u :u はi の(1<<x) こ上に存在する頂点",
            "    vector<vector<int>> par;",
            "    vector<int> dist;",
            "    int cnt = 1;",
            "    void calc(ff &f)",
            "    {",
            "        int rt = 0;",
            "        int n = sz(f);",
            "        while ((1 << cnt) < n)",
            "        {",
            "            cnt++;",
            "        }",
            "",
            "        par.resize(n, vector<int>(cnt, -1));",
            "        dist.resize(n, 0);",
            "        auto dfs = [&](auto rc, int x, int p) -> void",
            "        {",
            "            par[x][0] = p;",
            "            dist[x] = dist[p] + 1;",
            "            for (auto &g : f[x])",
            "            {",
            "                if (g.t != p)",
            "                {",
            "                    rc(rc, g.t, x);",
            "                }",
            "            }",
            "        };",
            "        dfs(dfs, rt, -1);",
            "",
            "        for (int i = 1; i < cnt; i++)",
            "        {",
            "            for (int x = 0; x < n; x++)",
            "            {",
            "                int p = par[x][i - 1];",
            "                par[x][i] = ((p == -1) ? -1 : par[p][i - 1]);",
            "            }",
            "        }",
            "    }",
            "",
            "    LCA() {}",
            "    LCA(ff &f)",
            "    {",
            "        calc(f);",
            "    }",
            "",
            "    int is_on_path(int u, int v, int x)",
            "    {",
            "        return (distance(u, v) == distance(u, x) + distance(x, v));",
            "    }",
            "    int distance(int u, int v)",
            "    {",
            "        return dist[u] + dist[v] - 2 * dist[this->operator()(u, v)];",
            "    }",
            "",
            "    inline vector<int> &operator[](int i)",
            "    {",
            "        return par.at(i);",
            "    }",
            "    int operator()(int u, int v)",
            "    {",
            "        if (dist[u] < dist[v])",
            "        {",
            "            swap(u, v);",
            "        }",
            "        for (int i = 0; i < cnt; i++)",
            "        {",
            "            if ((dist[u] - dist[v]) >> i & 1)",
            "            {",
            "                u = par[u][i];",
            "            }",
            "        }",
            "",
            "        if (u == v)",
            "        {",
            "            return u;",
            "        }",
            "        for (int i = cnt - 1; i >= 0; i--)",
            "        {",
            "            if (par[u][i] != par[v][i])",
            "            {",
            "                u = par[u][i];",
            "                v = par[v][i];",
            "            }",
            "        }",
            "",
            "        return par[u][0];",
            "    }",
            "};\n",
        ]
    },
    "pPRIM": {
        "prefix": "pPRIM",
        "body": [
            "class prim",
            "{",
            "public:",
            "    ff f;",
            "    long long cost;",
            "    prim(ff &F) : f(sz(F)), cost(0)",
            "    {",
            "        minpq<gg> q;",
            "        for (auto &g : F[0])",
            "        {",
            "            q.push(g);",
            "        }",
            "",
            "        set<int> st;",
            "        st.insert(0);",
            "        while (sz(st) != sz(F))",
            "        {",
            "            auto g = q.top();",
            "            q.pop();",
            "            if (st.count(g.t))",
            "            {",
            "                continue;",
            "            }",
            "",
            "            f(g);",
            "            f(g());",
            "            cost += g.l;",
            "            st.insert(g.t);",
            "",
            "            for (auto &ng : F[g.t])",
            "            {",
            "                if (st.count(ng.t))",
            "                {",
            "                    continue;",
            "                }",
            "",
            "                q.push(ng);",
            "            }",
            "        }",
            "    }",
            "    vector<gg> &operator[](int i)",
            "    {",
            "        return f[i];",
            "    }",
            "};\n",
        ]
    },
    "pTPS": {
        "prefix": "pTPS",
        "body": [
            "class TPS",
            "{",
            "    bool notunq = false;",
            "",
            "public:",
            "    int n;",
            "    vector<int> v;",
            "    void calc(ff &f)",
            "    {",
            "        n = sz(f);",
            "        vector<int> inde(n, 0);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            for (auto &g : f[i])",
            "            {",
            "                inde[g.t]++;",
            "            }",
            "        }",
            "",
            "        queue<int> q;",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            if (inde[i] == 0)",
            "            {",
            "                q.push(i);",
            "            }",
            "        }",
            "",
            "        while (!q.empty())",
            "        {",
            "            if (sz(q) != 1)",
            "            {",
            "                notunq = true;",
            "            }",
            "            int x = q.front();",
            "            q.pop();",
            "            v.push_back(x);",
            "",
            "            for (auto &g : f[x])",
            "            {",
            "                if ((--inde[g.t]) == 0)",
            "                {",
            "                    q.push(g.t);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    TPS() {}",
            "    TPS(ff &f)",
            "    {",
            "        calc(f);",
            "    }",
            "",
            "    bool has_cycle()",
            "    {",
            "        return sz(v) != n;",
            "    }",
            "    bool is_not_unique()",
            "    {",
            "        return notunq;",
            "    }",
            "    int size()",
            "    {",
            "        return sz(v);",
            "    }",
            "    inline int &operator[](int i)",
            "    {",
            "        return v.at(i);",
            "    }",
            "};",
            "// グラフは連結であることが前提とされる\n",
        ]
    },
    "pSCC": {
        "prefix": "pSCC",
        "body": [
            "class SCC",
            "{",
            "public:",
            "    ff scc;",
            "    vector<int> component;",
            "    vector<int> component_size;",
            "    void calc(ff &f)",
            "    {",
            "        ff rf;",
            "        rf.reverse(f);",
            "        calc(f, rf);",
            "    }",
            "    void calc(ff &f, ff &rf)",
            "    {",
            "        int n = sz(f);",
            "        vector<int> used(n, 0);",
            "        vector<int> order;",
            "        order.reserve(n);",
            "        auto dfs = [&](auto rc, int i) -> void",
            "        {",
            "            used[i] = 1;",
            "            for (auto g : f[i])",
            "            {",
            "                if (!used[g.t])",
            "                {",
            "                    rc(rc, g.t);",
            "                }",
            "            }",
            "            order.push_back(i);",
            "        };",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            if (!used[i])",
            "            {",
            "                dfs(dfs, i);",
            "            }",
            "        }",
            "        reverse(order.begin(), order.end());",
            "",
            "        int cnt = 0;",
            "        component.resize(n, -1); // component -> 0index",
            "        auto rdfs = [&](auto rc, int ri) -> void",
            "        {",
            "            component[ri] = cnt;",
            "            for (auto g : rf[ri])",
            "            {",
            "                if (component[g.t] == -1)",
            "                {",
            "                    rc(rc, g.t);",
            "                }",
            "            }",
            "        };",
            "        for (auto &ri : order)",
            "        {",
            "            if (component[ri] == -1)",
            "            {",
            "                rdfs(rdfs, ri);",
            "                cnt++;",
            "            }",
            "        }",
            "",
            "        vector<set<int>> st(cnt);",
            "        component_size.resize(cnt, 0);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            int x = component[i];",
            "            component_size[x]++;",
            "            for (auto g : f[i])",
            "            {",
            "                int nxt = component[g.t];",
            "                if (x != nxt)",
            "                {",
            "                    st[x].insert(nxt);",
            "                }",
            "            }",
            "        }",
            "",
            "        scc.resize(cnt);",
            "        for (int x = 0; x < cnt; x++)",
            "        {",
            "            for (auto &nxt : st[x])",
            "            {",
            "                scc(gg(x, nxt));",
            "            }",
            "        }",
            "    }",
            "",
            "    SCC() {}",
            "    SCC(ff &f)",
            "    {",
            "        calc(f);",
            "    }",
            "    SCC(ff &f, ff &rf)",
            "    {",
            "        calc(f, rf);",
            "    }",
            "",
            "    bool is_same(int x, int y)",
            "    {",
            "        return component[x] == component[y];",
            "    }",
            "    int size()",
            "    {",
            "        return sz(scc);",
            "    }",
            "",
            "    inline vector<gg> &operator[](int i)",
            "    {",
            "        return scc[i];",
            "    }",
            "};\n",
        ]
    },
    "pANGLE": {
        "prefix": "pANGLE",
        "body": [
            "class angle",
            "{",
            "    double _deg, _rad;",
            "",
            "public:",
            "    static constexpr double pi = 3.141592653589793;",
            "    double deg()",
            "    {",
            "        return _deg;",
            "    }",
            "    double deg(double d)",
            "    {",
            "        _rad = pi / 180 * d;",
            "        return _deg = d;",
            "    }",
            "    double rad()",
            "    {",
            "        return _rad;",
            "    }",
            "    double rad(double r)",
            "    {",
            "        _rad = 180 / pi * r;",
            "        return _rad = r;",
            "    }",
            "};",
        ]
    },
    "pROTATE": {
        "prefix": "pROTATE",
        "body": [
            "#ifndef __Pnt__",
            "#define __Pnt__",
            "typedef class Pnt pnt;",
            "class Pnt",
            "{",
            "public:",
            "    double x, y;",
            "",
            "    Pnt(const double &X, const double &Y) : x(X), y(Y){};",
            "",
            "    pnt plc(const pnt &p)",
            "    {",
            "        x = p.x;",
            "        y = p.y;",
            "        return *this;",
            "    }",
            "    pnt mv(const pnt &p)",
            "    {",
            "        return pnt(x - p.x, y - p.y);",
            "    }",
            "",
            "    double len()",
            "    {",
            "        return sqrt(x * x + y * y);",
            "    }",
            "    pnt rotate(double &th)",
            "    {",
            "        double rad = th / 180 * acos(-1);",
            "        return pnt(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad));",
            "    }",
            "",
            "    void print()",
            "    {",
            "        printf(\"%.9lf %.9lf\\n\", x, y);",
            "    }",
            "};",
            "#endif // __Pnt__\n",
        ]
    },
    "pUF": {
        "prefix": "pUF",
        "body": [
            "class UF",
            "{",
            "private:",
            "    int n;",
            "    vector<long long> ptt;",
            "    vector<int> par;",
            "    int root(int x)",
            "    {",
            "        if (par.at(x) < 0)",
            "        {",
            "            return x;",
            "        }",
            "        int px = root(par[x]);",
            "        ptt[x] += ptt[par[x]];",
            "        return par[x] = px;",
            "    }",
            "    long long weight(int x)",
            "    {",
            "        root(x);",
            "        return ptt[x];",
            "    }",
            "",
            "public:",
            "    UF(int sz) : n(sz), ptt(sz, 0), par(sz, -1) {}",
            "    int size(int x)",
            "    {",
            "        return -par.at(root(x));",
            "    }",
            "    int size()",
            "    {",
            "        return n;",
            "    }",
            "    bool is_same(int x, int y)",
            "    {",
            "        return root(x) == root(y);",
            "    }",
            "    // w = [y] - [x];",
            "    void unite(int x, int y, long long w = 0)",
            "    {",
            "        w += weight(x);",
            "        w -= weight(y);",
            "        x = root(x);",
            "        y = root(y);",
            "",
            "        if (x == y)",
            "        {",
            "            return;",
            "        }",
            "",
            "        if (size(x) < size(y))",
            "        {",
            "            swap(x, y);",
            "            w *= -1;",
            "        }",
            "",
            "        par[x] += par[y];",
            "        par[y] = x;",
            "        ptt[y] = w;",
            "        n--;",
            "    }",
            "    long long diff(int x, int y)",
            "    {",
            "        return ptt[y] - ptt[x];",
            "    }",
            "",
            "    int operator[](int x)",
            "    {",
            "        return root(x);",
            "    }",
            "};",
            "// UF uf(頂点数);",
            "// is_same(x, y), unite(x, y), uf[x]:所属grp\n",
        ]
    },
    "pDAY": {
        "prefix": "pDAY",
        "body": [
            "// DAY",
            "typedef class DAY DAY;",
            "class DAY",
            "{",
            "private:",
            "    const long long int y_400 = 97;",
            "    vector<int> y_1{-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};",
            "    vector<string> dow{\"sun\", \"mon\", \"tues\", \"wednes\", \"thurs\", \"fri\", \"satur\"};",
            "",
            "    // この年の元旦から1_indexed に直す",
            "    // ex) 1,1 -> 1日",
            "    long long int this_year(long long int y, long long int m, long long int d)",
            "    {",
            "        long long int res = y_1[m] + d;",
            "",
            "        // ３月が始まっていたら閏年かどうかも考える",
            "        if (3 <= m && is_uru(y))",
            "        {",
            "            res++;",
            "        }",
            "",
            "        return res;",
            "    }\n",
            "public:",
            "    bool is_uru(int year)",
            "    {",
            "        if (year % 400 == 0)",
            "        {",
            "            return true;",
            "        }",
            "        if (year % 100 == 0)",
            "        {",
            "            return false;",
            "        }\n",
            "        return (year % 4 == 0);",
            "    }\n",
            "    // 西暦1 年1 月1 日から1_indexed に直す",
            "    // ex) 1,1,1 -> 1",
            "    long long int days(long long int y, long long int m, long long int d)",
            "    {",
            "        long long int res = this_year(y, m, d) + (--y) * 365;\n",
            "        // 400 年単位で計算する 閏年は400年に97回存在する",
            "        res += (y / 400) * y_400;",
            "        y %= 400;\n",
            "        // 閏年は少なくとも4 の倍数の年",
            "        for (int i = 4; i <= y; i += 4)",
            "        {",
            "            if (is_uru(i))",
            "            {",
            "                res++;",
            "            }",
            "        }\n",
            "        return res;",
            "    }\n",
            "    // 1_indexed なカレンダー上でnum 番目にある日付を計算する",
            "    // ex) 1 -> 1/1/1",
            "    void _days(long long int num, long long int &y, long long int &m, long long int &d)",
            "    {",
            "        y = m = d = 0;\n",
            "        y = num / (400 * 365 + y_400) * 400;",
            "        // y 年の年末までを考えたとき、400年単位で考えてあとnum%y_400 日経過すればよい",
            "        num %= (400 * 365 + y_400);\n",
            "        long long int y_from_400 = num / 365;",
            "        y += y_from_400;\n",
            "        num %= 365;",
            "        // 400 年単位以降の閏年を考慮しないならば、y 年の年末の時点からあとnum 日経過すればよい\n",
            "        for (int i = 4; i <= y_from_400; i += 4)",
            "        {",
            "            if (is_uru(i))",
            "            {",
            "                num--;",
            "            }",
            "        }\n",
            "        // 400 年単位以降の閏年を考慮した結果、y 年の年末の時点からあとnum 日経過するか、戻ればよい",
            "        // 戻る際はy-1 年までの年末を考えて、足し算していく(num==0 のときはｙ年の年末を指している)",
            "        if (num <= 0)",
            "        {",
            "            num += 365;",
            "            if (is_uru(y))",
            "            {",
            "                num++;",
            "            }",
            "        }",
            "        else",
            "        {",
            "            y++;",
            "        }\n",
            "        // この段階でy は決定している",
            "        while (y_1[m + 1] < num)",
            "        {",
            "            m++;",
            "            if (m == 3 && is_uru(y))",
            "            {",
            "                num--;",
            "            }",
            "        }\n",
            "        d = num - y_1[m];",
            "    }\n",
            "    int _day_of_week(long long int y, long long int m, long long int d)",
            "    {",
            "        return days(y, m, d) % 7;",
            "    }\n",
            "    string day_of_week(long long int y, long long int m, long long int d)",
            "    {",
            "        return dow[_day_of_week(y, m, d)] + \"day\";",
            "    }",
            "};\n",
        ]
    },
    "pNTT": {
        "prefix": "pNTT",
        "body": [
            "class NTT",
            "{",
            "private:",
            "    char char_11 = 'a';",
            "    char ll_to_char(long long int x)",
            "    {",
            "        if (0 <= x && x <= 9)",
            "        {",
            "            return x + '0';",
            "        }",
            "",
            "        return x - 10 + char_11;",
            "    }",
            "    long long int char_to_ll(char c)",
            "    {",
            "        if ('0' <= c && c <= '9')",
            "        {",
            "            return c - '0';",
            "        }",
            "",
            "        return c - char_11 + 10;",
            "    }",
            "",
            "public:",
            "    NTT() {}",
            "    NTT(char c11) : char_11(c11) {}",
            "",
            "    long long int to_10(const string &s, long long int ip)",
            "    {",
            "        long long int res = 0, pw = 1;",
            "        for (int i = sz(s) - 1; i >= 0; i--)",
            "        {",
            "            res += char_to_ll(s[i]) * pw;",
            "            pw *= ip;",
            "        }",
            "",
            "        return res;",
            "    }",
            "    string operator()(const string &s, long long int ip, long long int op)",
            "    {",
            "        string res;",
            "        long long int ll_10 = to_10(s, ip);",
            "        while (ll_10)",
            "        {",
            "            res += ll_to_char(ll_10 % op);",
            "            ll_10 /= op;",
            "        }",
            "",
            "        if (res == \"\")",
            "        {",
            "            return \"0\";",
            "        }",
            "        reverse(res.begin(), res.end());",
            "        return res;",
            "    }",
            "",
            "    string erase_0(const string &s)",
            "    {",
            "        for (int i = 0; i < sz(s); i++)",
            "        {",
            "            if (s[i] != '0')",
            "            {",
            "                return s.substr(i, sz(s));",
            "            }",
            "        }",
            "",
            "        return \"0\";",
            "    }",
            "};\n",
        ]
    },
    "pBIT": {
        "prefix": "pBIT",
        "body": [
            "template <typename T>",
            "class BIT",
            "{",
            "public:",
            "    int n;",
            "    vector<T> v;",
            "    BIT(int N = 0) : n(N + 1), v(n, 0) {}",
            "    BIT(vector<T> &V) : n(sz(V) + 1), v(n, 0)",
            "    {",
            "        int i = 0;",
            "        for (auto &x : V)",
            "        {",
            "            add(i++, x);",
            "        }",
            "    }",
            "",
            "    // 一点更新",
            "    void add(int i, T x)",
            "    {",
            "        for (i++; i < n; i += (i & -i)) // i は更新の度、立っている最下位ビット分加算される",
            "        {",
            "            v[i] += x;",
            "        }",
            "    }",
            "    // [0~i)",
            "    T sum(int i)",
            "    {",
            "        long long ret = 0;",
            "        for (; i > 0; i -= (i & -i))",
            "        {",
            "            ret += v[i];",
            "        }",
            "        return ret;",
            "    }",
            "    // [l~r)",
            "    T sum(int l, int r)",
            "    {",
            "        return sum(r) - sum(l);",
            "    }",
            "    long long inversion(vector<T> &v)",
            "    {",
            "        int n = sz(v);",
            "        BIT<long long> bt(n);",
            "        long long res = 0;",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            res += i - bt.sum(v[i]);",
            "            bt.add(v[i], 1);",
            "        }",
            "        return res;",
            "    }",
            "};\n",
        ]
    },
    "pSEG": {
        "prefix": "pSEG",
        "body": [
            "template <class T>",
            "class SEG",
            "{",
            "    T base;             // 配列の初期値",
            "    int l_edge, r_edge; // 基準配列に該当する両端の位置[l,r)",
            "    int sz_vec = 1;     // 基準配列のサイズを超える最小の2 のべき乗",
            "    vector<T> dat;",
            "    int btm(int i)",
            "    {",
            "        return i + sz_vec - 1;",
            "    }",
            "    int l_chi(int i)",
            "    {",
            "        return i * 2 + 1;",
            "    }",
            "    int r_chi(int i)",
            "    {",
            "        return i * 2 + 2;",
            "    }",
            "",
            "    // 変更を親にむけて伝播させる",
            "    void influence(int i)",
            "    {",
            "        while (i)",
            "        {",
            "            int par = (i - 1) / 2;",
            "            int chi = (i & 1 ? i + 1 : i - 1);",
            "            dat[par] = func_seg(dat[i], dat[chi]);",
            "            i = par;",
            "        }",
            "    }",
            "",
            "public:",
            "    SEG(const vector<T> &v, long long int BASE) : base(BASE)",
            "    {",
            "        while (sz_vec < sz(v))",
            "        {",
            "            sz_vec <<= 1;",
            "        }",
            "        l_edge = sz_vec - 1;",
            "        r_edge = sz_vec * 2 - 1;",
            "        dat.resize(r_edge, base);",
            "",
            "        for (int i = 0; i < sz(v); i++)",
            "        {",
            "            dat[btm(i)] = v[i];",
            "        }",
            "        for (int ri = btm(0) - 1; ri >= 0; ri--)",
            "        {",
            "            dat[ri] = func_seg(dat[l_chi(ri)], dat[r_chi(ri)]);",
            "        }",
            "    }",
            "",
            "    void set(int i, long long int x)",
            "    {",
            "        dat[btm(i)] = x;",
            "        influence(btm(i));",
            "    }",
            "    void add(int i, long long int x)",
            "    {",
            "        dat[btm(i)] = func_seg(dat[btm(i)], x);",
            "        influence(btm(i));",
            "    }",
            "    T operator()()",
            "    {",
            "        return this->operator()(0, sz_vec, 0, 0, sz_vec);",
            "    }",
            "    T operator()(int a, int b, int now = 0, int l = 0)",
            "    {",
            "        return this->operator()(a, b, 0, 0, sz_vec);",
            "    }",
            "    T operator()(int a, int b, int now, int l, int r)",
            "    {",
            "        if (a <= l && r <= b)",
            "        {",
            "            return dat[now];",
            "        }",
            "        if (r <= a || b <= l)",
            "        {",
            "            return base;",
            "        }",
            "        return func_seg(this->operator()(a, b, l_chi(now), l, (l + r) / 2), this->operator()(a, b, r_chi(now), (l + r) / 2, r));",
            "    }",
            "",
            "    inline T &operator[](int i)",
            "    {",
            "        return dat[btm(i)];",
            "    }",
            "",
            "    void print()",
            "    {",
            "        int now = 2;",
            "        for (int i = 0; i < sz(dat); i++)",
            "        {",
            "            cout << dat[i] << \",\";",
            "            if (bitset<32>(now++).count() == 1)",
            "            {",
            "                cout << endl;",
            "            }",
            "        }",
            "    }",
            "    T func_seg(T l, T r)",
            "    {",
            "        return $0;",
            "    }",
            "};\n",
        ]
    },
    "pLSG": {
        "prefix": "pLSG",
        "body": [
            "template <typename T>",
            "class datval",
            "{",
            "    T _val;",
            "    T _lazy;",
            "",
            "public:",
            "    bool is_reflected = false;",
            "    datval(T base) : _lazy(base){};",
            "",
            "    T lazy()",
            "    {",
            "        return _lazy;",
            "    }",
            "    T lazy(T x)",
            "    {",
            "        is_reflected = false;",
            "        return _lazy = x;",
            "    }",
            "    T val()",
            "    {",
            "        if (is_reflected == false)",
            "        {",
            "            return val(_lazy);",
            "        }",
            "        return _val;",
            "    }",
            "    T val(T x)",
            "    {",
            "        is_reflected = true;",
            "        return _val = x;",
            "    }",
            "};",
            "",
            "template <class T>",
            "class LSG",
            "{",
            "    int sz_vec = 1; // 基準配列のサイズを超える最小の2 のべき乗",
            "    T base;         // 配列の初期値",
            "",
            "    int l_chi(int i)",
            "    {",
            "        return i * 2 + 1;",
            "    }",
            "    int r_chi(int i)",
            "    {",
            "        return i * 2 + 2;",
            "    }",
            "",
            "public:",
            "    vector<datval<T>> dat;",
            "    LSG(const vector<T> &v, T BASE) : base(BASE)",
            "    {",
            "        while (sz_vec < sz(v))",
            "        {",
            "            sz_vec <<= 1;",
            "        }",
            "        dat.resize(sz_vec * 2 - 1, base);",
            "",
            "        int now = sz_vec - 1 + sz(v);",
            "        while (now--)",
            "        {",
            "            int i = now - sz_vec + 1;",
            "            (i < 0 ? dat[now].val(func(dat[l_chi(now)].val(), dat[r_chi(now)].val())) : dat[now].lazy(v[i]));",
            "        }",
            "    }",
            "",
            "    void eval(int now)",
            "    {",
            "        if (dat[now].is_reflected == true)",
            "        {",
            "            return;",
            "        }",
            "        if (now < sz_vec - 1)",
            "        {",
            "            dat[r_chi(now)].lazy(dat[l_chi(now)].lazy((dat[now].lazy())));",
            "        }",
            "        dat[now].val();",
            "    }",
            "",
            "    void update(int a, int b, T x, int now, int l, int r)",
            "    {",
            "        eval(now);",
            "        if (a <= l && r <= b)",
            "        {",
            "            dat[now].lazy(x);",
            "            eval(now);",
            "        }",
            "        else if (a < r && l < b)",
            "        {",
            "            update(a, b, x, l_chi(now), l, (l + r) / 2);",
            "            update(a, b, x, r_chi(now), (l + r) / 2, r);",
            "            dat[now].val(func(dat[l_chi(now)].val(), dat[r_chi(now)].val()));",
            "        }",
            "    }",
            "    void update(int a, int b, T x, int now = 0, int l = 0)",
            "    {",
            "        update(a, b, x, now, l, sz_vec);",
            "    }",
            "",
            "    T operator()(int a, int b, int now, int l, int r)",
            "    {",
            "        eval(now);",
            "        if (r <= a || b <= l)",
            "        {",
            "            return base;",
            "        }",
            "        else if (a <= l && r <= b)",
            "        {",
            "            return dat[now].val();",
            "        }",
            "        else",
            "        {",
            "            return func(this->operator()(a, b, l_chi(now), l, (l + r) / 2), this->operator()(a, b, r_chi(now), (l + r) / 2, r));",
            "        }",
            "    }",
            "    T operator()(int a, int b, int now = 0, int l = 0)",
            "    {",
            "        return this->operator()(a, b, 0, 0, sz_vec);",
            "    }",
            "",
            "    inline T operator[](int i) { return this->operator()(i, i + 1, 0, 0, sz_vec); }",
            "    void print()",
            "    {",
            "        int now = 2;",
            "        for (auto &dv : dat)",
            "        {",
            "            cout << dv.val() << \",\";",
            "            if (bitset<32>(now++).count() == 1)",
            "            {",
            "                cout << endl;",
            "            }",
            "        }",
            "    }",
            "    T func(T l, T r)",
            "    {",
            "        return $0;",
            "    }",
            "};\n",
        ]
    },
    "pPRIME": {
        "prefix": "pPRIME",
        "body": [
            "class factor",
            "{",
            "public:",
            "    long long int prime;",
            "    int exponent;",
            "    factor(long long int x, int y) : prime(x), exponent(y){};",
            "    void print()",
            "    {",
            "        printf(\"%6lld ^ %6d\\n\", prime, exponent);",
            "    }",
            "};",
            "class prm",
            "{",
            "public:",
            "    vector<long long> primes;",
            "    map<long long, vector<factor>> prime_map;",
            "    prm(long long upper_limit_sq)",
            "    {",
            "        assert(upper_limit_sq < 1e16);",
            "        int siz = sqrt(upper_limit_sq) + 2;",
            "",
            "        vector<bool> erat(siz, true);",
            "        for (int i = 2; i < siz; i++)",
            "        {",
            "            if (erat[i])",
            "            {",
            "                primes.push_back(i);",
            "                prime_map[i] = vector<factor>(1, factor(i, 1));",
            "                for (int j = (i << 1); j < siz; j += i)",
            "                {",
            "                    erat[j] = false;",
            "                }",
            "            }",
            "        }",
            "    }",
            "    bool is_prime(long long int x)",
            "    {",
            "        return (this->operator[](x).begin()->prime == x);",
            "    }",
            "    vector<long long int> divisors(long long int x)",
            "    {",
            "        vector<long long> divs(1, 1);",
            "        for (auto &fac : this->operator[](x))",
            "        {",
            "            for (int ri = sz(divs) - 1; ri >= 0; ri--)",
            "            {",
            "                long long d = 1;",
            "                for (int i = 0; i < fac.exponent; i++)",
            "                {",
            "                    d *= fac.prime;",
            "                    divs.push_back(divs[ri] * d);",
            "                }",
            "            }",
            "        }",
            "        sort(divs.begin(), divs.end());",
            "        return divs;",
            "    }",
            "    vector<factor> &operator[](long long x)",
            "    {",
            "        auto &res = prime_map[x];",
            "        if (sz(res) == 0)",
            "        {",
            "            for (auto &pm : primes)",
            "            {",
            "                int tms = 0;",
            "                while (x % pm == 0)",
            "                {",
            "                    x /= pm;",
            "                    tms++;",
            "                }",
            "                if (tms)",
            "                {",
            "                    res.push_back(factor(pm, tms));",
            "                }",
            "                if (x == 1)",
            "                {",
            "                    return res;",
            "                }",
            "            }",
            "            res.push_back(factor(x, 1));",
            "        }",
            "        return res;",
            "    }",
            "};\n",
        ]
    },
    "pCLCL": {
        "prefix": "pCLCL",
        "body": [
            "class CLCL",
            "{",
            "    using T = long long int;",
            "    vector<T> tails;",
            "    vector<T> cycle;",
            "",
            "public:",
            "    long long int tail, period;",
            "    CLCL(T x)",
            "    {",
            "        map<T, int> mp;",
            "        int odr = 0;",
            "        while (!mp.count(x))",
            "        {",
            "            mp[x] = odr++;",
            "            x = func(x);",
            "        }",
            "        tail = mp[x];",
            "        period = odr - tail;",
            "",
            "        tails.resize(tail);",
            "        cycle.resize(period);",
            "        for (auto &x : mp)",
            "        {",
            "            if (x.second < tail)",
            "            {",
            "                tails[x.second] = x.first;",
            "            }",
            "            else",
            "            {",
            "                cycle[x.second - tail] = x.first;",
            "            }",
            "        }",
            "    }",
            "    T operator[](int i)",
            "    {",
            "        return cycle.at(i);",
            "    }",
            "    // tms 回操作を繰り返した際の初期値の変化後の値",
            "    T operator()(long long int tms)",
            "    {",
            "        if (tms < tail)",
            "        {",
            "            return tails[tms];",
            "        }",
            "        tms -= tail;",
            "        tms %= period;",
            "        return cycle[tms];",
            "    }",
            "",
            "    T func(T x)",
            "    {",
            "        $0",
            "    }",
            "};\n",
        ]
    },
    "pRESTORE": {
        "prefix": "pRESTORE",
        "body": [
            "template <typename T>",
            "class restore",
            "{",
            "    vector<T> S;",
            "",
            "public:",
            "    vector<int> compress, decrypt;",
            "    map<T, int> mp;",
            "    restore(vector<T> &R) : compress(sz(R)), decrypt(sz(R))",
            "    {",
            "        S = R;",
            "        sort(S.begin(), S.end());",
            "",
            "        for (int i = 0; i < sz(R); i++)",
            "        {",
            "            if (mp.count(R[i]))",
            "            {",
            "                decrypt[++mp[R[i]]] = i;",
            "                continue;",
            "            }",
            "            int pos = lower_bound(S.begin(), S.end(), R[i]) - S.begin();",
            "            decrypt[pos] = i;",
            "            mp[R[i]] = pos;",
            "        }",
            "",
            "        int now = 0;",
            "        for (auto &x : mp)",
            "        {",
            "            x.second = now++;",
            "        }",
            "        for (int i = 0; i < sz(R); i++)",
            "        {",
            "            compress[i] = mp[R[i]];",
            "        }",
            "    }",
            "    int size()",
            "    {",
            "        return sz(mp);",
            "    }",
            "    inline T &operator[](int i)",
            "    {",
            "        return S.at(i);",
            "    }",
            "};",
            "// compress[i] -> comressed_random[i]",
            "// decrypt[i]  -> restoration_random[i]",
            "// re[i]       -> random[decrypt[i]] == sorted[i]\n",
        ]
    },
    "pMATRIX": {
        "prefix": "pMATRIX",
        "body": [
            "class matrix",
            "{",
            "public:",
            "    const int n, m;",
            "    vector<vector<double>> v;",
            "    matrix(const matrix &mat) : n(mat.n), m(mat.m), v(mat.v) {}",
            "    matrix(int N, int M, double x = 0) : n(N), m(M), v(n, vector<double>(m, x)) {}",
            "    matrix(const vector<double> &vec) : n(sz(vec)), m(n), v(n, vector<double>(m, 0))",
            "    {",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            v[i][i] = vec[i];",
            "        }",
            "    }",
            "",
            "    matrix operator=(matrix mat)",
            "    {",
            "        v = mat.v;",
            "        // v = move(mat.v);",
            "        return *this;",
            "    }",
            "    matrix operator*(matrix &mat)",
            "    {",
            "        assert(m == mat.n);",
            "        matrix res(n, mat.m);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            for (int j = 0; j < mat.m; j++)",
            "            {",
            "                for (int k = 0; k < m; k++)",
            "                {",
            "                    res[i][j] += v[i][k] * mat[k][j];",
            "                }",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    inline vector<double> &operator[](int i)",
            "    {",
            "        return v.at(i);",
            "    }",
            "};\n",
        ]
    },
    "pAFFINE": {
        "prefix": "pAFFINE",
        "body": [
            "class Affine",
            "{",
            "    matrix _scale, _move, _rotate, _reflectX, _reflectY;",
            "",
            "public:",
            "    Affine() : _scale(vector<double>{1, 1, 1}), _move(_scale), _rotate(_scale), _reflectX(_scale), _reflectY(_scale)",
            "    {",
            "        _reflectX[1][1] = -1;",
            "        _reflectY[0][0] = -1;",
            "    }",
            "",
            "    matrix scale(matrix &mat, double x, double y)",
            "    {",
            "        _scale[0][0] = x;",
            "        _scale[1][1] = y;",
            "        return mat = _scale * mat;",
            "    }",
            "    // 加算する",
            "    matrix move(matrix &mat, double x, double y)",
            "    {",
            "        _move[0][2] = x;",
            "        _move[1][2] = y;",
            "        return mat = _move * mat;",
            "    }",
            "    matrix reflectX(matrix &mat)",
            "    {",
            "        return mat = _reflectX * mat;",
            "    }",
            "    matrix reflectY(matrix &mat)",
            "    {",
            "        return mat = _reflectY * mat;",
            "    }",
            "    // 反時計回り radian で渡す",
            "    matrix rotate(matrix &mat, double theta)",
            "    {",
            "        _rotate[0][0] = _rotate[1][1] = cos(theta);",
            "        double sinth = sin(theta);",
            "        _rotate[0][1] = -sinth;",
            "        _rotate[1][0] = sinth;",
            "        return mat = _rotate * mat;",
            "    }",
            "};\n",
        ]
    },
}