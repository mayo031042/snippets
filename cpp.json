{
    "pSHOW": {
        "prefix": "pSHOW",
        "body": [
            "// pSHOW",
            "// vmin: vector[all]--;",
            "// mm: mod",
            "// pPWR: power",
            "// pNCK: nck",
            "// pGG: edge",
            "// pGH: graph",
            "// pDIJK: dijkstra",
            "// pROTATE: 点の回転",
            "// pUF: union find",
            "// pDAY: 日付計算",
            "// pNTT: 進数表記変換",
        ],
        "description": ""
    },

    "p": {
        "prefix": "p",
        "body": [
            "#include <iostream>",
            "#include <fstream>",
            "#include <vector>",
            "#include <string>",
            "#include <algorithm>",
            "#include <queue>",
            "#include <map>",
            "#include <set>",
            "#include <bitset>",
            "#include <cmath>",
            "// #include <atcoder/all>",
            "using namespace std;",
            "using ll = long long int;",
            "using ss = string;",
            "using db = double;",
            "template <class T>",
            "using minpq = priority_queue<T, vector<T>, greater<T>>;",
            "const int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};",
            "const int dy[8] = {0, 1, 0, -1, 1, -1, -1, 1};",
            "#define V vector",
            "#define pii pair<int, int>",
            "#define pll pair<ll, ll>",
            "#define all(v) v.begin(), v.end()",
            "#define rall(v) v.rbegin(), v.rend()",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define sz(x) int(x.size())",
            "#define yn                 \\",
            "    cout << \"Yes\" << endl; \\",
            "    else cout << \"No\" << endl",
            "#define YN                 \\",
            "    cout << \"YES\" << endl; \\",
            "    else cout << \"NO\" << endl",
            "template <class T>",
            "T chmax(T &x, const T &y)",
            "{",
            "    return x = max(x, y);",
            "}",
            "template <class T>",
            "T chmin(T &x, const T &y)",
            "{",
            "    return x = min(x, y);",
            "}",
            "template <class T>",
            "void align(T &x, T &y)",
            "{",
            "    if (x > y)",
            "    {",
            "        swap(x, y);",
            "    }",
            "}",
            "",
            "int main()",
            "{",
			"\t$1",
            "}",
        ],
        "description": ""
    },

    "rep": {
        "prefix": "rep",
        "body": [
            "for (int $1 = $2; $1 < $3; $1++)",
            "{",
            "\t$4",
            "}\n$5",
        ],
        "description": ""
    },
    "rrep": {
        "prefix": "rrep",
        "body": [
            "for (int $1 = $3 - 1; $1 >= $2; $1--)",
            "{",
            "\t$4",
            "}\n$5",
        ],
        "description": ""
    },
    
    "col": {
        "prefix": "col",
        "body": [
            "cout << $1 << endl;\n",
        ],
        "description": ""
    },

    
    "pol": {
        "prefix": "pol",
        "body": [
            "printf(\"%.9lf\\n\", $1);\n",
        ],
        "description": ""
    },

    "ctt": {
        "prefix": "ctt",
        "body": [
            "$1 $2;",
            "cin >> $2;\n",
        ],
        "description": ""
    },


    "cct": {
        "prefix": "cct",
        "body": [
            "$1 $2, $3;",
            "cin >> $2 >> $3;\n",
        ],
        "description": ""
    },

    "cii": {
        "prefix": "cii",
        "body": [
            "int $1;",
            "cin >> $1;\n",
        ],
        "description": ""
    },

    "cci": {
        "prefix": "cci",
        "body": [
            "int $1, $2;",
            "cin >> $1 >> $2;\n",
        ],
        "description": ""
    },

    "cll": {
        "prefix": "cll",
        "body": [
            "ll $1;",
            "cin >> $1;\n",
        ],
        "description": ""
    },

    "ccl": {
        "prefix": "ccl",
        "body": [
            "ll $1, $2;",
            "cin >> $1 >> $2;\n",
        ],
        "description": ""
    },
    
    "cvt": {
        "prefix": "cvt",
        "body": [
            "vector<$1> $2($3);",
            "for (int i = 0; i < $3; i++)",
            "{",
            "\tcin >> $2[i];",
            "}\n",
        ],
        "description": ""
    },
    
    "cvvt": {
        "prefix": "cvvt",
        "body": [
            "vector<vector<$1>> $2($3, vector<$1>($4));",
            "for (int i = 0; i < $3; i++)",
            "{",
            "\tfor (int j = 0; j < $4; j++)",
            "\t{",
            "\t\tcin >> $2[i][j];",
            "\t}",
            "}\n",
        ],
        "description": ""
    },
    
    "ret": {
        "prefix": "ret",
        "body": [
            "return $1;",
            "$2",
        ],
        "description": ""
    },

    "vmin": {
        "prefix": "vmin",
        "body": [
            "for (int i = 0; i < $2; i++)",
            "{",
            "\t$1[i]--;",
            "}\n",
        ],
        "description": ""
    },

    "ato": {
        "prefix": "ato",
        "body": [
            "for (auto &$1 : $2)",
            "{",
            "\t$3",
            "}\n",
        ],
        "description": ""
    },

    "srt": {
        "prefix": "srt",
        "body": [
            "sort($1.begin(), $1.end());\n"
        ],
        "description": ""
    },

    "rsrt": {
        "prefix": "rsrt",
        "body": [
            "sort($1.rbegin(), $1.rend());\n"
        ],
        "description": ""
    },

    "dans": {
        "prefix": "dans",
        "body": [
            "$1 ans = $2;\n",
            "cout << ans << endl;"
        ],
        "description": ""
    },

    "mm": {
        "prefix": "mm",
        "body": [
            "#ifndef MOD",
            "#define MOD",
            "ll mod = ${1|1e9 + 7,998244353|};",
            "#endif // MOD\n",
        ],
        "description": ""
    },

    // Algorithm
    "pPWR": {
        "prefix": "pPWR",
        "body": [
            "#ifndef MOD",
            "#define MOD",
            "ll mod = 1e9 + 7;",
            "#endif // MOD\n",
            "ll pwr(ll x, ll n)",
            "{",
            "    if (n & 1)",
            "    {",
            "        return pwr(x, n - 1) * x % mod;",
            "    }",
            "    if (!n)",
            "    {",
            "        return 1;",
            "    }",
            "    ll ans = pwr(x, n / 2);",
            "    return ans * ans % mod;",
            "}\n"
        ],
        "description": "",
    },
        "pNCK": {
        "prefix": "pNCK",
        "body": [
            "#ifndef MOD",
            "#define MOD",
            "ll mod = 1e9 + 7;",
            "#endif // MOD",
            "",
            "typedef class nck nck;",
            "class nck",
            "{",
            "public:",
            "    ll max_size = 1e6 + 5;",
            "    vector<ll> fac, fac_inv, inv;",
            "    void vec_resize(vector<ll> &v)",
            "    {",
            "        v.resize(max_size);",
            "        v[0] = v[1] = 1;",
            "    }",
            "    nck()",
            "    {",
            "        vec_resize(fac);",
            "        vec_resize(fac_inv);",
            "        vec_resize(inv);",
            "",
            "        for (ll i = 2; i < max_size; i++)",
            "        {",
            "            fac[i] = fac[i - 1] * i % mod;",
            "            inv[i] = mod - inv[mod % i] * (mod / i) % mod;",
            "            fac_inv[i] = fac_inv[i - 1] * inv[i] % mod;",
            "        }",
            "    }",
            "",
            "    ll operator()(ll n, ll k)",
            "    {",
            "        if (n < k || n < 0 || k < 0)",
            "        {",
            "            return 0;",
            "        }",
            "        return fac[n] * fac_inv[n - k] % mod * fac_inv[k] % mod;",
            "    }",
            "};\n",
        ],
        "description": ""
    },
  
    "pGG": {
        "prefix": "pGG",
        "body": [
            "#ifndef __GG__",
            "#define __GG__",
            "typedef class GG gg;",
            "class GG",
            "{",
            "public:",
            "    int f, t;",
            "    ll l;",
            "    GG(int F, int T, ll L) : f(F), t(T), l(L){};",
            "    gg reverse()",
            "    {",
            "        return gg(t, f, l);",
            "    }",
            "};",
            "bool operator>(const gg &g0, const gg g1) { return g0.l > g1.l; }",
            "#endif // __GG__\n\n",
        ],
        "description": ""
    },

    "pGH": {
        "prefix": "pGH",
        "body": [
            "#ifndef __GH__",
            "#define __GH__",
            "typedef class GH gh;",
            "class GH",
            "{",
            "public:",
            "    int sz, edz = 0;",
            "    vector<vector<gg>> gph;",
            "    GH(int n)",
            "    {",
            "        gph.resize(sz = n);",
            "    }",
            "    int add(const gg &g)",
            "    {",
            "        gph[g.f].push_back(g);",
            "        return ++edz;",
            "    }",
            "    vector<gg> operator[](int i)",
            "    {",
            "        return gph[i];",
            "    }",
            "};",
            "#endif // __GH__\n\n",
        ],
        "description": ""
    },

    "pDIJK": {
        "prefix": "pDIJK",
        "body": [
            "#ifndef __DIJK__",
            "#define __DIJK__",
            "typedef class DIJK di;",
            "class DIJK",
            "{",
            "    ll inf = 3e18;",
            "",
            "public:",
            "    vector<ll> operator()(gh &g, int from = 0)",
            "    {",
            "        minpq<gg> q;",
            "        vector<ll> dist(g.sz, inf);",
            "        dist[from] = 0;",
            "        for (gg &e : g[from])",
            "        {",
            "            q.push(e);",
            "        }",
            "        while (!q.empty())",
            "        {",
            "            gg e = q.top();",
            "            q.pop();",
            "            if (dist[e.t] > dist[e.f] + e.l)",
            "            {",
            "                dist[e.t] = dist[e.f] + e.l;",
            "                for (gg &ed : g[e.t])",
            "                {",
            "                    if (dist[ed.t] > dist[ed.f] + ed.l)",
            "                    {",
            "                        q.push(ed);",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "};",
            "#endif // __DIJK__\n\n",
        ],
        "description": ""
    },

    "pROTATE": {
        "prefix": "pROTATE",
        "body": [
            "#ifndef __Pnt__",
            "#define __Pnt__",
            "typedef class Pnt pnt;",
            "class Pnt",
            "{",
            "public:",
            "    db x, y;",
            "",
            "    Pnt(const db &X, const db &Y) : x(X), y(Y){};",
            "",
            "    pnt plc(const pnt &p)",
            "    {",
            "        x = p.x;",
            "        y = p.y;",
            "        return *this;",
            "    }",
            "    pnt mv(const pnt &p)",
            "    {",
            "        return pnt(x - p.x, y - p.y);",
            "    }",
            "",
            "    db len()",
            "    {",
            "        return sqrt(x * x + y * y);",
            "    }",
            "    pnt rotate(db &th)",
            "    {",
            "        db rad = th / 180 * acos(-1);",
            "        return pnt(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad));",
            "    }",
            "",
            "    void print()",
            "    {",
            "        printf(\"%.9lf %.9lf\\n\", x, y);",
            "    }",
            "};",
            "#endif // __Pnt__\n",
        ],
        "description": ""
    },

    "pUF": {
        "prefix": "pUF",
        "body": [
            "// UF",
            "typedef class UF uf;",
            "class uf",
            "{",
            "private:",
            "    int n, N;",
            "    vector<int> par;",
            "",
            "public:",
            "    uf(int sz) : n(sz), N(sz)",
            "    {",
            "        par.resize(n, -1);",
            "    }",
            "",
            "    int operator[](int x)",
            "    {",
            "        return root(x);",
            "    }",
            "    int root(int x)",
            "    {",
            "        if (par[x] < 0)",
            "        {",
            "            return x;",
            "        }",
            "        return par[x] = root(par[x]);",
            "    }",
            "",
            "    int size(int x)",
            "    {",
            "        return -par[root(x)];",
            "    }",
            "    int grp_size()",
            "    {",
            "        return N;",
            "    }",
            "    bool is_same(int x, int y)",
            "    {",
            "        return root(x) == root(y);",
            "    }",
            "    void unite(int x, int y)",
            "    {",
            "        x = root(x);",
            "        y = root(y);",
            "        if (!is_same(x, y))",
            "        {",
            "            if (size(x) < size(y))",
            "            {",
            "                swap(x, y);",
            "            }",
            "            par[x] += par[y];",
            "            par[y] = x;",
            "            N--;",
            "        }",
            "    }",
            "};\n",
        ],
        "description": ""
    },

    "pDAY": {
        "prefix": "pDAY",
        "body": [
            "// DAY",
            "typedef class DAY DAY;",
            "class DAY",
            "{",
            "private:",
            "    const ll y_400 = 97;",
            "    vector<int> y_1{-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};",
            "    vector<ss> dow{\"sun\", \"mon\", \"tues\", \"wednes\", \"thurs\", \"fri\", \"satur\"};",
            "",
            "    // この年の元旦から1_indexed に直す",
            "    // ex) 1,1 -> 1日",
            "    ll this_year(ll y, ll m, ll d)",
            "    {",
            "        ll res = y_1[m] + d;",
            "",
            "        // ３月が始まっていたら閏年かどうかも考える",
            "        if (3 <= m && is_uru(y))",
            "        {",
            "            res++;",
            "        }",
            "",
            "        return res;",
            "    }\n",
            "public:",
            "    bool is_uru(int year)",
            "    {",
            "        if (year % 400 == 0)",
            "        {",
            "            return true;",
            "        }",
            "        if (year % 100 == 0)",
            "        {",
            "            return false;",
            "        }\n",
            "        return (year % 4 == 0);",
            "    }\n",
            "    // 西暦1 年1 月1 日から1_indexed に直す",
            "    // ex) 1,1,1 -> 1",
            "    ll days(ll y, ll m, ll d)",
            "    {",
            "        ll res = this_year(y, m, d) + (--y) * 365;\n",
            "        // 400 年単位で計算する 閏年は400年に97回存在する",
            "        res += (y / 400) * y_400;",
            "        y %= 400;\n",
            "        // 閏年は少なくとも4 の倍数の年",
            "        for (int i = 4; i <= y; i += 4)",
            "        {",
            "            if (is_uru(i))",
            "            {",
            "                res++;",
            "            }",
            "        }\n",
            "        return res;",
            "    }\n",
            "    // 1_indexed なカレンダー上でnum 番目にある日付を計算する",
            "    // ex) 1 -> 1/1/1",
            "    void _days(ll num, ll &y, ll &m, ll &d)",
            "    {",
            "        y = m = d = 0;\n",
            "        y = num / (400 * 365 + y_400) * 400;",
            "        // y 年の年末までを考えたとき、400年単位で考えてあとnum%y_400 日経過すればよい",
            "        num %= (400 * 365 + y_400);\n",
            "        ll y_from_400 = num / 365;",
            "        y += y_from_400;\n",
            "        num %= 365;",
            "        // 400 年単位以降の閏年を考慮しないならば、y 年の年末の時点からあとnum 日経過すればよい\n",
            "        for (int i = 4; i <= y_from_400; i += 4)",
            "        {",
            "            if (is_uru(i))",
            "            {",
            "                num--;",
            "            }",
            "        }\n",
            "        // 400 年単位以降の閏年を考慮した結果、y 年の年末の時点からあとnum 日経過するか、戻ればよい",
            "        // 戻る際はy-1 年までの年末を考えて、足し算していく(num==0 のときはｙ年の年末を指している)",
            "        if (num <= 0)",
            "        {",
            "            num += 365;",
            "            if (is_uru(y))",
            "            {",
            "                num++;",
            "            }",
            "        }",
            "        else",
            "        {",
            "            y++;",
            "        }\n",
            "        // この段階でy は決定している",
            "        while (y_1[m + 1] < num)",
            "        {",
            "            m++;",
            "            if (m == 3 && is_uru(y))",
            "            {",
            "                num--;",
            "            }",
            "        }\n",
            "        d = num - y_1[m];",
            "    }\n",
            "    int _day_of_week(ll y, ll m, ll d)",
            "    {",
            "        return days(y, m, d) % 7;",
            "    }\n",
            "    ss day_of_week(ll y, ll m, ll d)",
            "    {",
            "        return dow[_day_of_week(y, m, d)] + \"day\";",
            "    }",
            "};\n",
        ],
        "description": ""
    },

    "pNTT": {
        "prefix": "pNTT",
        "body": [
            "typedef class NTT NTT;",
            "class NTT",
            "{",
            "private:",
            "    char _char(ll x)",
            "    {",
            "        if (x < 10)",
            "        {",
            "            return x + '0';",
            "        }\n",
            "        return x - 10 + 'a';",
            "    }",
            "    ll _ll(char c)",
            "    {",
            "        if ('0' <= c && c <= '9')",
            "        {",
            "            return c - '0';",
            "        }\n",
            "        return c - 'a' + 10;",
            "    }\n",
            "public:",
            "    // 10進数でのll 型数値に変換する",
            "    ll to_10(const ss &x, ll from)",
            "    {",
            "        return stol(cng(x, from, 10));",
            "    }\n",
            "    ss cng(const ss &x, ll from, ll to)",
            "    {",
            "        ll y = 0, z = 1;",
            "        ss res = \"\";\n",
            "        for (int i = sz(x) - 1; 0 <= i; i--)",
            "        {",
            "            y += z * _ll(x[i]);",
            "            z *= from;",
            "        }",
            "        while (y)",
            "        {",
            "            res = _char(y % to) + res;",
            "            y /= to;",
            "        }\n",
            "        return res;",
            "    }\n",
            "    ss erase_0(const ss &s)",
            "    {",
            "        rep(i, 0, sz(s))",
            "        {",
            "            if (s[i] != '0')",
            "            {",
            "                return s.substr(i, sz(s));",
            "            }",
            "        }\n",
            "        return \"0\";",
            "    }",
            "};\n",
        ],
        "description": ""
    },

    "SEG": {
        "prefix": "pSEG",
        "body": [
            "// seg木",
            "typedef class SEG SEG;",
            "class SEG",
            "{",
            "    using T = ll;",
            "    // 関数",
            "    inline T func(T l, T r)",
            "    {",
            "        return $1max(l, r);",
            "    }",
            "",
            "    int n;",
            "    T base;",
            "    V<T> dat;",
            "",
            "    void build(const V<T> &v)",
            "    {",
            "        for (int i = 0; i < sz(v); i++)",
            "        {",
            "            dat[i + n - 1] = v[i];",
            "        }",
            "        for (int now = n - 2; now >= 0; now--)",
            "        {",
            "            dat[now] = func(dat[now * 2 + 1], dat[now * 2 + 2]);",
            "        }",
            "    }",
            "",
            "    // 変更を親にむけて伝播させる",
            "    void influence(int i)",
            "    {",
            "        int now = i + n - 1;",
            "        while (now)",
            "        {",
            "            int par = (now - 1) / 2;",
            "            int chi = par * 2 + 1;",
            "            if (now == chi)",
            "            {",
            "                chi++;",
            "            }",
            "",
            "            dat[par] = func(dat[now], dat[chi]);",
            "            now = par;",
            "        }",
            "    }",
            "",
            "public:",
            "    SEG(const V<T> &v, T BASE) : base(BASE)",
            "    {",
            "        n = 1;",
            "        while (n < sz(v))",
            "        {",
            "            n <<= 1;",
            "        }",
            "",
            "        dat.resize(n * 2 - 1, base);",
            "        build(v);",
            "    }",
            "",
            "    // 書き換え",
            "    void set(int i, T x)",
            "    {",
            "        dat[i + n - 1] = x;",
            "        influence(i);",
            "    }",
            "    // 更新",
            "    void add(int i, T x)",
            "    {",
            "        dat[i + n - 1] = func(dat[i + n - 1], x);",
            "        influence(i);",
            "    }",
            "",
            "    T range_(int a, int b, int now, int l, int r)",
            "    {",
            "        // 完全に範囲内ならdat を返す",
            "        if (a <= l && r <= b)",
            "        {",
            "            return dat[now];",
            "        }",
            "        // 完全に範囲外なら影響なし",
            "        if (r <= a || b <= l)",
            "        {",
            "            return base;",
            "        }",
            "        // 重なっているので分割する",
            "        return func(range_(a, b, now * 2 + 1, l, (l + r) / 2), range_(a, b, now * 2 + 2, (l + r) / 2, r));",
            "    }",
            "",
            "    T range(int a, int b)",
            "    {",
            "        return range_(a, b, 0, 0, n);",
            "    }",
            "",
            "    // SEG をもとの配列と同様に扱える",
            "    inline T operator[](int i)",
            "    {",
            "        return dat[i + n - 1];",
            "    }",
            "",
            "    void print()",
            "    {",
            "        int x, y;",
            "        x = y = 2;",
            "        for (int now = 0; now < n * 2 - 1; now++)",
            "        {",
            "            cout << dat[now] << \",\";",
            "            if (y == x++)",
            "            {",
            "                y <<= 1;",
            "                cout << endl;",
            "            }",
            "        }",
            "    }",
            "};",
            "",
        ],
        "description": ""
    },

}
