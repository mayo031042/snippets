{
    "pppall": {
        "prefix": "pppall",
        "body": [
            "",
        ],
        "description": ""
    },



    "p": {
        "prefix": "p",
        "body": [
            "#include <iostream>",
            "#include <vector>",
            "#include <string>",
            "#include <algorithm>",
            "#include <queue>",
            "#include <map>",
            "#include <set>",
            "#include <bitset>",
            "#include <cmath>",
            "// #include <atcoder/all>",
            "using namespace std;",
            "using ll = long long int;",
            "using ss = string;",
            "using db = double;",
            "template <class T>",
            "using minpq = priority_queue<T, vector<T>, greater<T>>;",
            "const int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};",
            "const int dy[8] = {0, 1, 0, -1, 1, -1, -1, 1};",
            "#define V vector",
            "#define pii pair<int, int>",
            "#define pll pair<ll, ll>",
            "#define rep(i, s, n) for (ll i = (s); i < (ll)(n); i++)",
            "#define all(v) v.begin(), v.end()",
            "#define rall(v) v.rbegin(), v.rend()",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define sz(x) int(x.size())",
            "#define yn                 \\",
            "    cout << \"Yes\" << endl; \\",
            "    else cout << \"No\" << endl",
            "#define YN                 \\",
            "    cout << \"YES\" << endl; \\",
            "    else cout << \"NO\" << endl",
            "template <class T>",
            "T chmax(T &x, const T &y)",
            "{",
            "    return x = max(x, y);",
            "}",
            "template <class T>",
            "T chmin(T &x, const T &y) { return x = min(x, y); }",
            "",
            "int main()",
            "{",
			"\t$1",
            "}",
        ],
        "description": ""
    },

    "rrep": {
        "prefix": "rrep",
        "body": [
            "for (int $1 = $2; $3 <= $1; $1--)",
            "{",
            "\t$4",
            "}",
        ],
        "description": ""
    },
    
    "col": {
        "prefix": "col",
        "body": [
            "cout << $1 << endl;\n",
        ],
        "description": ""
    },

    
    "pol": {
        "prefix": "pol",
        "body": [
            "printf(\"%.9lf\\n\", $1);\n",
        ],
        "description": ""
    },

    "ctt": {
        "prefix": "ctt",
        "body": [
            "$1 $2;",
            "cin >> $2;\n",
        ],
        "description": ""
    },


    "cct": {
        "prefix": "cct",
        "body": [
            "$1 $2, $3;",
            "cin >> $2 >> $3;\n",
        ],
        "description": ""
    },

    "cii": {
        "prefix": "cii",
        "body": [
            "int $1;",
            "cin >> $1;\n",
        ],
        "description": ""
    },

    "cci": {
        "prefix": "cci",
        "body": [
            "int $1, $2;",
            "cin >> $1 >> $2;\n",
        ],
        "description": ""
    },

    "cll": {
        "prefix": "cll",
        "body": [
            "ll $1;",
            "cin >> $1;\n",
        ],
        "description": ""
    },

    "ccl": {
        "prefix": "ccl",
        "body": [
            "ll $1, $2;",
            "cin >> $1 >> $2;\n",
        ],
        "description": ""
    },

    "cvt": {
        "prefix": "cvt",
        "body": [
            "vector<$1> $2($3);",
            "for (int i = 0; i < $3; i++)",
            "{",
            "\tcin >> $2[i];",
            "}\n",
        ],
        "description": ""
    },

    "vmin": {
        "prefix": "vmin",
        "body": [
            "for (int i = 0; i < $2; i++)",
            "{",
            "\t$1[i]--;",
            "}\n",
        ],
        "description": ""
    },

    "cvvt": {
        "prefix": "cvvt",
        "body": [
            "vector<vector<$1>> $2($3, vector<$1>($4));",
            "for (int i = 0; i < $3; i++)",
            "{",
            "\tfor (int j = 0; j < $4; j++)",
            "\t{",
            "\t\tcin >> $2[i][j];",
            "\t}",
            "}\n",
        ],
        "description": ""
    },

    "rev": {
        "prefix": "rev",
        "body": [
            "for (int $1 = $3 - 1; $1 >= $2; $1--)",
            "{",
            "\t$4",
            "}\n$5",
        ],
        "description": ""
    },

    "ato": {
        "prefix": "ato",
        "body": [
            "for (auto &$1 : $2)",
            "{",
            "\t$3",
            "}\n",
        ],
        "description": ""
    },

    "srt": {
        "prefix": "srt",
        "body": [
            "sort($1.begin(), $1.end());\n"
        ],
        "description": ""
    },

    "rsrt": {
        "prefix": "rsrt",
        "body": [
            "sort($1.rbegin(), $1.rend());\n"
        ],
        "description": ""
    },

    "dans": {
        "prefix": "dans",
        "body": [
            "$1 ans = $2;\n",
            "cout << ans << endl;"
        ],
        "description": ""
    },

    "mm": {
        "prefix": "mm",
        "body": [
            "#ifndef MOD",
            "#define MOD",
            "ll mod = ${1|1e9 + 7,998244353|};",
            "#endif // MOD",
            "",
        ],
        "description": ""
    },

    // Algorithm

    "nck": {
        "prefix": "com",
        "body": [
            "typedef class Comb com;",
            "class Comb",
            "{",
            "    int len = 6e5;",
            "    vector<ll> Fac, Inv, Finv;",
            "",
            "public:",
            "    Comb()",
            "    {",
            "        Fac.resize(len);",
            "        Inv.resize(len);",
            "        Finv.resize(len);",
            "        Fac[0] = Fac[1] = Inv[1] = Finv[0] = Finv[1] = 1;",
            "",
            "        rep(i, 2, len)",
            "        {",
            "            Fac[i] = Fac[i - 1] * i % mod;",
            "            Inv[i] = mod - Inv[mod % i] * (mod / i) % mod;",
            "            Finv[i] = Finv[i - 1] * Inv[i] % mod;",
            "        }",
            "    }",
            "    ll operator()(ll n, ll k)",
            "    {",
            "        if (n < k || n < 0 || k < 0 || n >= len)",
            "        {",
            "            return 0;",
            "        }",
            "",
            "        return Fac[n] * (Finv[n - k] * Finv[k] % mod) % mod;",
            "    }",
            "};",
            "",
        ],
        "description": ""
    },

    "pUF": {
        "prefix": "pUF",
        "body": [
            "// UF",
            "typedef class UF UF;",
            "class UF",
            "{",
            "private:",
            "    int n, N;",
            "    vector<int> par;",
            "",
            "public:",
            "    UF(int sz) : n(sz), N(sz)",
            "    {",
            "        // 自身から見て１つ上の親のノードを示す",
            "        // 自身が最親ならば負の数でサイズを表す",
            "        par.resize(n, -1);",
            "    }",
            "",
            "    // uf[x] はx の最親を返す",
            "    int operator[](int x)",
            "    {",
            "        return root(x);",
            "    }",
            "",
            "    // 再帰的に最親を探して返す",
            "    int root(int x)",
            "    {",
            "        if (par[x] < 0)",
            "        {",
            "            return x;",
            "        }",
            "        return par[x] = root(par[x]);",
            "    }",
            "",
            "    // 指定したノードが属するグループのサイズを返す",
            "    int size(int x)",
            "    {",
            "        return -par[root(x)];",
            "    }",
            "",
            "    // グループの数を返す",
            "    int grp_size()",
            "    {",
            "        return N;",
            "    }",
            "",
            "    // x, y が同じグループに属するならtrue",
            "    bool is_same(int x, int y)",
            "    {",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    // x, y を同じグループにする",
            "    // もともと同じなら何もしない",
            "    void unite(int x, int y)",
            "    {",
            "        x = root(x);",
            "        y = root(y);",
            "        if (!is_same(x, y))",
            "        {",
            "            if (size(x) < size(y))",
            "            {",
            "                swap(x, y);",
            "            }",
            "            // サイズの更新",
            "            par[x] += par[y];",
            "            // 最親の更新",
            "            par[y] = x;",
            "            // 統合されたので総グループ数は減る",
            "            N--;",
            "        }",
            "    }",
            "};",
            "",
        ],
        "description": ""
    },

    "pDAY": {
        "prefix": "pDAY",
        "body": [
            "// DAY",
            "typedef class DAY DAY;",
            "class DAY",
            "{",
            "private:",
            "    const ll y_400 = 97;",
            "    vector<int> y_1{-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};",
            "    vector<ss> dow{\"sun\", \"mon\", \"tues\", \"wednes\", \"thurs\", \"fri\", \"satur\"};",
            "",
            "    // この年の元旦から1_indexed に直す",
            "    // ex) 1,1 -> 1日",
            "    ll this_year(ll y, ll m, ll d)",
            "    {",
            "        ll res = y_1[m] + d;",
            "",
            "        // ３月が始まっていたら閏年かどうかも考える",
            "        if (3 <= m && is_uru(y))",
            "        {",
            "            res++;",
            "        }",
            "",
            "        return res;",
            "    }",
            "",
            "public:",
            "    bool is_uru(int year)",
            "    {",
            "        if (year % 400 == 0)",
            "        {",
            "            return true;",
            "        }",
            "        if (year % 100 == 0)",
            "        {",
            "            return false;",
            "        }",
            "",
            "        return (year % 4 == 0);",
            "    }",
            "",
            "    // 西暦１年１月１日から1_indexed に直す",
            "    // ex) 1,1,1 -> 1",
            "    ll days(ll y, ll m, ll d)",
            "    {",
            "        ll res = this_year(y, m, d) + (--y) * 365;",
            "",
            "        // 400 年単位で計算する　閏年は400年に97回存在する",
            "        res += (y / 400) * y_400;",
            "        y %= 400;",
            "",
            "        // 閏年は少なくとも４の倍数の年",
            "        for (int i = 4; i <= y; i += 4)",
            "        {",
            "            if (is_uru(i))",
            "            {",
            "                res++;",
            "            }",
            "        }",
            "",
            "        return res;",
            "    }",
            "",
            "    // 1_indexed なカレンダー上でnum 番目にある日付を計算する",
            "    // ex) 1 -> 1/1/1",
            "    void _days(ll num, ll &y, ll &m, ll &d)",
            "    {",
            "        y = m = d = 0;",
            "",
            "        y = num / (400 * 365 + y_400) * 400;",
            "        // y 年の年末までを考えたとき、400年単位で考えてあとnum%y_400 日経過すればよい",
            "        num %= (400 * 365 + y_400);",
            "",
            "        ll y_from_400 = num / 365;",
            "        y += y_from_400;",
            "",
            "        num %= 365;",
            "        // ４００年単位以降の閏年を考慮しないならば、y 年の年末の時点からあとnum 日経過すればよい",
            "",
            "        for (int i = 4; i <= y_from_400; i += 4)",
            "        {",
            "            if (is_uru(i))",
            "            {",
            "                num--;",
            "            }",
            "        }",
            "",
            "        // ４００年単位以降の閏年を考慮した結果、y 年の年末の時点からあとnum 日経過するか、戻ればよい",
            "        // 戻る際はy-1 年までの年末を考えて、足し算していく(num==0 のときはｙ年の年末を指している)",
            "        if (num <= 0)",
            "        {",
            "            num += 365;",
            "            if (is_uru(y))",
            "            {",
            "                num++;",
            "            }",
            "        }",
            "        else",
            "        {",
            "            y++;",
            "        }",
            "",
            "        // この段階でy は決定している",
            "        while (y_1[m + 1] < num)",
            "        {",
            "            m++;",
            "            if (m == 3 && is_uru(y))",
            "            {",
            "                num--;",
            "            }",
            "        }",
            "",
            "        d = num - y_1[m];",
            "    }",
            "",
            "    int",
            "    _day_of_week(ll y, ll m, ll d)",
            "    {",
            "        return days(y, m, d) % 7;",
            "    }",
            "",
            "    ss day_of_week(ll y, ll m, ll d)",
            "    {",
            "        return dow[_day_of_week(y, m, d)] + \"day\";",
            "    }",
            "};",
        ],
        "description": ""
    },

    "pNTT": {
        "prefix": "pNTT",
        "body": [
            "typedef class NTT NTT;",
            "class NTT",
            "{",
            "private:",
            "    char _char(ll x)",
            "    {",
            "        if (x < 10)",
            "        {",
            "            return x + '0';",
            "        }",
            "",
            "        return x - 10 + 'a';",
            "    }",
            "    ll _ll(char c)",
            "    {",
            "        if ('0' <= c && c <= '9')",
            "        {",
            "            return c - '0';",
            "        }",
            "",
            "        return c - 'a' + 10;",
            "    }",
            "",
            "public:",
            "    // 10進数でのll 型数値に変換する",
            "    ll to_10(const ss &x, ll from)",
            "    {",
            "        return stol(cng(x, from, 10));",
            "    }",
            "",
            "    ss cng(const ss &x, ll from, ll to)",
            "    {",
            "        ll y = 0, z = 1;",
            "        ss res = \"\";",
            "",
            "        for (int i = sz(x) - 1; 0 <= i; i--)",
            "        {",
            "            y += z * _ll(x[i]);",
            "            z *= from;",
            "        }",
            "        while (y)",
            "        {",
            "            res = _char(y % to) + res;",
            "            y /= to;",
            "        }",
            "",
            "        return res;",
            "    }",
            "",
            "    ss erase_0(const ss &s)",
            "    {",
            "        rep(i, 0, sz(s))",
            "        {",
            "            if (s[i] != '0')",
            "            {",
            "                return s.substr(i, sz(s));",
            "            }",
            "        }",
            "",
            "        return \"0\";",
            "    }",
            "};",
            "",
        ],
        "description": ""
    },

    "SEG": {
        "prefix": "pSEG",
        "body": [
            "// seg木",
            "typedef class SEG SEG;",
            "class SEG",
            "{",
            "    using T = ll;",
            "    // 関数",
            "    inline T func(T l, T r)",
            "    {",
            "        return $1max(l, r);",
            "    }",
            "",
            "    int n;",
            "    T base;",
            "    V<T> dat;",
            "",
            "    void build(const V<T> &v)",
            "    {",
            "        for (int i = 0; i < sz(v); i++)",
            "        {",
            "            dat[i + n - 1] = v[i];",
            "        }",
            "        for (int now = n - 2; now >= 0; now--)",
            "        {",
            "            dat[now] = func(dat[now * 2 + 1], dat[now * 2 + 2]);",
            "        }",
            "    }",
            "",
            "    // 変更を親にむけて伝播させる",
            "    void influence(int i)",
            "    {",
            "        int now = i + n - 1;",
            "        while (now)",
            "        {",
            "            int par = (now - 1) / 2;",
            "            int chi = par * 2 + 1;",
            "            if (now == chi)",
            "            {",
            "                chi++;",
            "            }",
            "",
            "            dat[par] = func(dat[now], dat[chi]);",
            "            now = par;",
            "        }",
            "    }",
            "",
            "public:",
            "    SEG(const V<T> &v, T BASE) : base(BASE)",
            "    {",
            "        n = 1;",
            "        while (n < sz(v))",
            "        {",
            "            n <<= 1;",
            "        }",
            "",
            "        dat.resize(n * 2 - 1, base);",
            "        build(v);",
            "    }",
            "",
            "    // 書き換え",
            "    void set(int i, T x)",
            "    {",
            "        dat[i + n - 1] = x;",
            "        influence(i);",
            "    }",
            "    // 更新",
            "    void add(int i, T x)",
            "    {",
            "        dat[i + n - 1] = func(dat[i + n - 1], x);",
            "        influence(i);",
            "    }",
            "",
            "    T range_(int a, int b, int now, int l, int r)",
            "    {",
            "        // 完全に範囲内ならdat を返す",
            "        if (a <= l && r <= b)",
            "        {",
            "            return dat[now];",
            "        }",
            "        // 完全に範囲外なら影響なし",
            "        if (r <= a || b <= l)",
            "        {",
            "            return base;",
            "        }",
            "        // 重なっているので分割する",
            "        return func(range_(a, b, now * 2 + 1, l, (l + r) / 2), range_(a, b, now * 2 + 2, (l + r) / 2, r));",
            "    }",
            "",
            "    T range(int a, int b)",
            "    {",
            "        return range_(a, b, 0, 0, n);",
            "    }",
            "",
            "    // SEG をもとの配列と同様に扱える",
            "    inline T operator[](int i)",
            "    {",
            "        return dat[i + n - 1];",
            "    }",
            "",
            "    void print()",
            "    {",
            "        int x, y;",
            "        x = y = 2;",
            "        for (int now = 0; now < n * 2 - 1; now++)",
            "        {",
            "            cout << dat[now] << \",\";",
            "            if (y == x++)",
            "            {",
            "                y <<= 1;",
            "                cout << endl;",
            "            }",
            "        }",
            "    }",
            "};",
            "",
        ],
        "description": ""
    },

}
