{
    "pSHOW": {
        "prefix": "pSHOW",
        "body": [
            "// pSHOW",
            "// vmin: vector[all]--;",
            "// mm: mod",
            "// pGCD: gcd",
            "// pPOW<-mm : power",
            "// pNCK<-mm : nck",
            "// pRNG: lx, ly, rx, ry",
            "// pIMS<-RNG : imosu hou",
            "// pGG: edge",
            "// pFF: graph",
            "// pDIJK<-pFF : Dijkstra",
            "// pBELF<-pFF : BellmanFord",
            "// pROTATE: 点の回転",
            "// pUF: union find",
            "// pDAY: 日付計算",
            "// pNTT: 進数表記変換",
            "// pCLCL: 周期性処理",
        ],
        "description": ""
    },
    "p": {
        "prefix": "p",
        "body": [
            "#include <iostream>",
            "#include <fstream>",
            "#include <vector>",
            "#include <string>",
            "#include <algorithm>",
            "#include <queue>",
            "#include <map>",
            "#include <set>",
            "#include <bitset>",
            "#include <cmath>",
            "// #include <atcoder/all>",
            "using namespace std;",
            "template <class T>",
            "using minpq = priority_queue<T, vector<T>, greater<T>>;",
            "const int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};",
            "const int dy[8] = {0, 1, 0, -1, 1, -1, -1, 1};",
            "#define pii pair<int, int>",
            "#define pll pair<long long int, long long int>",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define sz(x) int(x.size())",
            "#define yn(x) cout << ((x) ? \"Yes\" : \"No\") << endl",
            "template <class T>",
            "T chmax(T &x, const T &y)",
            "{",
            "    return x = max(x, y);",
            "}",
            "template <class T>",
            "T chmin(T &x, const T &y)",
            "{",
            "    return x = min(x, y);",
            "}",
            "template <class T>",
            "void align(T &x, T &y)",
            "{",
            "    if (x > y)",
            "    {",
            "        swap(x, y);",
            "    }",
            "}",
            "void et(string s)",
            "{",
            "    cout << s << endl;",
            "    exit(0);",
            "}",
            "",
            "int main()",
            "{",
            "\t$0",
            "}",
        ],
        "description": ""
    },
    "ll": {
        "prefix": "ll",
        "body": [
            "long long int $0",
        ],
        "description": ""
    },
    "ss": {
        "prefix": "ss",
        "body": [
            "string $0",
        ],
        "description": ""
    },
    "dd": {
        "prefix": "dd",
        "body": [
            "double $0",
        ],
        "description": ""
    },
    "pCLASS": {
        "prefix": "pCLASS",
        "body": [
            "class $1",
            "{",
            "public:\n\t$0",
            "    $1(){}",
            "    void operator()()",
            "{\n}",
            "};",
        ],
        "description": ""
    },
    "rep": {
        "prefix": "rep",
        "body": [
            "for (int $1 = $2; $1 < $3; $1++)",
            "{",
            "\t$0",
            "}\n",
        ],
        "description": ""
    },
    "rrep": {
        "prefix": "rrep",
        "body": [
            "for (int $1 = $3 - 1; $1 >= $2; $1--)",
            "{",
            "\t$0",
            "}\n",
        ],
        "description": ""
    },
    "ww": {
        "prefix": "ww",
        "body": [
            "vector<vector<$1>> $2($3, vector<$1>($4, $5));\n",
        ],
        "description": ""
    },
    "vv": {
        "prefix": "vv",
        "body": [
            "vector<$0>",
        ],
        "description": ""
    },
    "qq": {
        "prefix": "qq",
        "body": [
            "queue<$0>",
        ],
        "description": ""
    },
    "all": {
        "prefix": "all",
        "body": [
            "$1.begin(), $1.end()$0"
        ],
        "description": ""
    },
    "rall": {
        "prefix": "rall",
        "body": [
            "$1.rbegin(), $1.rend()$0"
        ],
        "description": ""
    },
    "col": {
        "prefix": "col",
        "body": [
            "cout << $1 << endl;\n",
        ],
        "description": ""
    },
    "pol": {
        "prefix": "pol",
        "body": [
            "printf(\"%.9lf\\n\", $1);\n",
        ],
        "description": ""
    },
    "ctt": {
        "prefix": "ctt",
        "body": [
            "$1 $2;",
            "cin >> $2;\n",
        ],
        "description": ""
    },
    "cct": {
        "prefix": "cct",
        "body": [
            "$1 $2, $3;",
            "cin >> $2 >> $3;\n",
        ],
        "description": ""
    },
    "cii": {
        "prefix": "cii",
        "body": [
            "int $1;",
            "cin >> $1;\n",
        ],
        "description": ""
    },
    "cci": {
        "prefix": "cci",
        "body": [
            "int $1, $2;",
            "cin >> $1 >> $2;\n",
        ],
        "description": ""
    },
    "cll": {
        "prefix": "cll",
        "body": [
            "long long int $1;",
            "cin >> $1;\n",
        ],
        "description": ""
    },
    "ccl": {
        "prefix": "ccl",
        "body": [
            "long long int $1, $2;",
            "cin >> $1 >> $2;\n",
        ],
        "description": ""
    },
    "css": {
        "prefix": "css",
        "body": [
            "string $1;",
            "cin >> $1;\n",
        ],
        "description": ""
    },
    "cvt": {
        "prefix": "cvt",
        "body": [
            "vector<$1> $2($3);",
            "for (int i = 0; i < $3; i++)",
            "{",
            "\tcin >> $2[i];",
            "}\n",
        ],
        "description": ""
    },
    "cvvt": {
        "prefix": "cvvt",
        "body": [
            "vector<vector<$1>> $2($3, vector<$1>($4));",
            "for (int i = 0; i < $3; i++)",
            "{",
            "\tfor (int j = 0; j < $4; j++)",
            "\t{",
            "\t\tcin >> $2[i][j];",
            "\t}",
            "}\n",
        ],
        "description": ""
    },
    "ret": {
        "prefix": "ret",
        "body": [
            "return $1;\n$0"
        ],
        "description": ""
    },
    "vmin": {
        "prefix": "vmin",
        "body": [
            "for (int i = 0; i < $2; i++)",
            "{",
            "\t$1[i]--;",
            "}\n",
        ],
        "description": ""
    },
    "ato": {
        "prefix": "ato",
        "body": [
            "for (auto &$1 : $2)",
            "{",
            "\t$0",
            "}\n",
        ],
        "description": ""
    },
    "srt": {
        "prefix": "srt",
        "body": [
            "sort($1.begin(), $1.end());\n"
        ],
        "description": ""
    },
    "rsrt": {
        "prefix": "rsrt",
        "body": [
            "sort($1.rbegin(), $1.rend());\n"
        ],
        "description": ""
    },
    "dans": {
        "prefix": "dans",
        "body": [
            "$1 ans = $2;\n$0",
            "cout << ans << endl;"
        ],
        "description": ""
    },
    "mm": {
        "prefix": "mm",
        "body": [
            "long long int P = ${1|1e9 + 7, 998244353|};",
        ],
        "description": ""
    },
    "next_combination": {
        "prefix": "next_combination",
        "body": [
            "template <typename Iterator>",
            "inline bool next_combination(const Iterator first, Iterator k, const Iterator last)",
            "{",
            "    /* Credits: Thomas Draper */",
            "    if ((first == last) || (first == k) || (last == k))",
            "    {",
            "        return false;",
            "    }",
            "    Iterator itr1 = first;",
            "    Iterator itr2 = last;",
            "    ++itr1;",
            "    if (last == itr1)",
            "    {",
            "        return false;",
            "    }",
            "    itr1 = last;",
            "    --itr1;",
            "    itr1 = k;",
            "    --itr2;",
            "    while (first != itr1)",
            "    {",
            "        if (*--itr1 < *itr2)",
            "        {",
            "            Iterator j = k;",
            "            while (!(*itr1 < *j))",
            "            {",
            "                ++j;",
            "            }",
            "            iter_swap(itr1, j);",
            "            ++itr1;",
            "            ++j;",
            "            itr2 = k;",
            "            rotate(itr1, j, last);",
            "            while (last != j)",
            "            {",
            "                ++j;",
            "                ++itr2;",
            "            }",
            "            rotate(k, itr2, last);",
            "            return true;",
            "        }",
            "    }",
            "    rotate(first, k, last);",
            "    return false;",
            "}",
            "do {} while (next_combination($1.begin(), $1.begin() + $2, $1.end()));",
            "",
        ],
        "description": ""
    },
    // Algorithm
    "pRNG": {
        "prefix": "pRNG",
        "body": [
            "class RANGE",
            "{",
            "public:",
            "    int lx, ly, rx, ry;",
            "    RANGE &operator()(int LX, int LY, int RX, int RY)",
            "    {",
            "        lx = LX;",
            "        ly = LY;",
            "        rx = RX;",
            "        ry = RY;",
            "        return *this;",
            "    }",
            "    RANGE &cin()",
            "    {",
            "        std::cin >> lx >> ly >> rx >> ry;",
            "        return *this;",
            "    }",
            "    RANGE &small()",
            "    {",
            "        rx--;",
            "        ry--;",
            "        return *this;",
            "    }",
            "};",
            "RANGE RNG;\n",
        ],
        "description": ""
    },
    "pIMS": {
        "prefix": "pIMS",
        "body": [
            "class IMOSU",
            "{",
            "public:",
            "    int h, w;",
            "    bool is_calced;",
            "    vector<vector<long long int>> v;",
            "",
            "    void operator()(int H, int W)",
            "    {",
            "        h = H + 1;",
            "        w = W + 1;",
            "        v.resize(h);",
            "        for (int i = 0; i < h; i++)",
            "        {",
            "            v[i].resize(w, 0);",
            "        }",
            "    }",
            "",
            "    void add(RANGE &rg)",
            "    {",
            "        v[rg.lx][rg.ly]++;",
            "        v[rg.lx][rg.ry]--;",
            "        v[rg.rx][rg.ly]--;",
            "        v[rg.rx][rg.ry]++;",
            "        is_calced = false;",
            "    }",
            "    void calc()",
            "    {",
            "        if (is_calced == true)",
            "        {",
            "            return;",
            "        }",
            "",
            "        for (int i = 0; i < h; i++)",
            "        {",
            "            for (int j = 1; j < w; j++)",
            "            {",
            "                v[i][j] += v[i][j - 1];",
            "            }",
            "        }",
            "        for (int j = 0; j < w; j++)",
            "        {",
            "            for (int i = 1; i < h; i++)",
            "            {",
            "                v[i][j] += v[i - 1][j];",
            "            }",
            "        }",
            "",
            "        is_calced = true;",
            "    }",
            "",
            "    vector<long long int> &operator[](int i)",
            "    {",
            "        calc();",
            "        return v[i];",
            "    }",
            "};",
            "IMOSU IMS;\n",
        ],
        "description": ""
    },
    "pGCD": {
        "prefix": "pGCD",
        "body": [
            "class gcd",
            "{",
            "    using T = long long int;",
            "    T _gcd(T x, T y)",
            "    {",
            "        return (y ? _gcd(y, x % y) : x);",
            "    }",
            "",
            "public:",
            "    T operator()(T first)",
            "    {",
            "        return first;",
            "    }",
            "    template <class... Rest>",
            "    T operator()(T first, Rest... rest)",
            "    {",
            "        return _gcd(first, this->operator()(rest...));",
            "    }",
            "};",
            "gcd GCD;\n",
        ],
        "description": ""
    },
    "pPOW": {
        "prefix": "pPOW",
        "body": [
            "long long int pwr(long long int x, long long int n)",
            "{",
            "    if (n & 1)",
            "    {",
            "        return pwr(x, n - 1) * x % P;",
            "    }",
            "    if (!n)",
            "    {",
            "        return 1;",
            "    }",
            "    long long int ans = pwr(x, n / 2);",
            "    return ans * ans % P;",
            "}\n",
        ],
        "description": "mm"
    },
    "pNCK": {
        "prefix": "pNCK",
        "body": [
            "class nck",
            "{",
            "public:",
            "    using T = long long int;",
            "    T max_size = 1e6 + 5;",
            "    vector<T> fac, fac_inv, inv;",
            "    void vec_resize(vector<T> &v)",
            "    {",
            "        v.resize(max_size);",
            "        v[0] = v[1] = 1;",
            "    }",
            "    nck()",
            "    {",
            "        vec_resize(fac);",
            "        vec_resize(fac_inv);",
            "        vec_resize(inv);",
            "        for (T i = 2; i < max_size; i++)",
            "        {",
            "            fac[i] = fac[i - 1] * i % P;",
            "            inv[i] = P - inv[P % i] * (P / i) % P;",
            "            fac_inv[i] = fac_inv[i - 1] * inv[i] % P;",
            "        }",
            "    }",
            "",
            "    T operator()(T n, T k)",
            "    {",
            "        if (n < k || n < 0 || k < 0)",
            "        {",
            "            return 0;",
            "        }",
            "        return fac[n] * fac_inv[n - k] % P * fac_inv[k] % P;",
            "    }",
            "};",
            "nck NCK;\n",
        ],
        "description": "mm"
    },
    "pGG": {
        "prefix": "pGG",
        "body": [
            "class gg",
            "{",
            "public:",
            "    int f, t;",
            "    long long int l;",
            "    gg() {}",
            "    gg(int F, int T, long long int L) : f(F), t(T), l(L) {}",
            "    gg &cft()",
            "    {",
            "        cin >> f >> t;",
            "        return *this;",
            "    }",
            "    gg &cftl()",
            "    {",
            "        cin >> f >> t >> l;",
            "        return *this;",
            "    }",
            "    gg &minus()",
            "    {",
            "        f--;",
            "        t--;",
            "        return *this;",
            "    }",
            "    gg reverse()",
            "    {",
            "        return gg(t, f, l);",
            "    }",
            "};",
            "bool operator>(const gg &g0, const gg g1) { return g0.l > g1.l; }\n",
        ],
        "description": ""
    },
    "pFF": {
        "prefix": "pFF",
        "body": [
            "class ff",
            "{",
            "public:",
            "    int sz, edz = 0;",
            "    vector<vector<gg>> v;",
            "    ff(int n)",
            "    {",
            "        v.resize(sz = n);",
            "    }",
            "    int add(const gg &g)",
            "    {",
            "        v[g.f].push_back(g);",
            "        return ++edz;",
            "    }",
            "    vector<gg> &operator[](int i)",
            "    {",
            "        return v[i];",
            "    }",
            "    int size()",
            "    {",
            "        return sz;",
            "    }",
            "};\n",
        ],
        "description": "pGG"
    },
    "pDIJK": {
        "prefix": "pDIJK",
        "body": [
            "class dijk",
            "{",
            "    long long int inf = 3e18;",
            "",
            "public:",
            "    vector<long long int> operator()(ff &f, int from = 0)",
            "    {",
            "        minpq<gg> q;",
            "        vector<long long int> dist(f.sz, inf);",
            "        dist[from] = 0;",
            "        for (gg &g : f[from])",
            "        {",
            "            q.push(g);",
            "        }",
            "        while (!q.empty())",
            "        {",
            "            gg g = q.top();",
            "            q.pop();",
            "            if (dist[g.t] > dist[g.f] + g.l)",
            "            {",
            "                dist[g.t] = dist[g.f] + g.l;",
            "                for (gg &nx : f[g.t])",
            "                {",
            "                    if (dist[nx.t] > dist[nx.f] + nx.l)",
            "                    {",
            "                        q.push(nx);",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "};",
            "dijk DIJK;\n",
        ],
        "description": "pFF"
    },
    "pBELF": {
        "prefix": "pBELF",
        "body": [
            "class BELF",
            "{",
            "    long long int inf = (1ll << 60);",
            "    vector<long long int> dist;",
            "    int n;",
            "",
            "    bool belf(vector<int> &p, bool has_negative_circuit = false)",
            "    {",
            "        bool changed = false;",
            "        for (int rp = 0; rp < n; rp++)",
            "        {",
            "            changed = false;",
            "            for (int i = 0; i < n; i++)",
            "            {",
            "                for (auto &g : f[i])",
            "                {",
            "                    if (dist[g.f] == inf)",
            "                    {",
            "                        continue;",
            "                    }",
            "",
            "                    long long int d = dist[g.f] + g.l;",
            "                    if (d < dist[g.t])",
            "                    {",
            "                        changed = true;",
            "",
            "                        if (has_negative_circuit)",
            "                        {",
            "                            dist[g.t] = -inf;",
            "                        }",
            "                        else",
            "                        {",
            "                            dist[g.t] = d;",
            "                            p[g.t] = g.f;",
            "                        }",
            "                    }",
            "                }",
            "            }",
            "",
            "            if (!changed)",
            "            {",
            "                break;",
            "            }",
            "        }",
            "",
            "        return changed;",
            "    }",
            "",
            "public:",
            "    ff &f;",
            "    vector<int> path;",
            "",
            "    BELF(ff &F) : f(F)",
            "    {",
            "        n = sz(f);",
            "        dist.resize(n, inf);",
            "        path.resize(n, -1);",
            "    }",
            "    long long int operator[](int i)",
            "    {",
            "        return dist.at(i);",
            "    }",
            "",
            "    // 到達不可能または負の閉路の影響を受ける場合true",
            "    bool is_inf(int i)",
            "    {",
            "        return std::abs(dist.at(i)) == inf;",
            "    }",
            "",
            "    bool operator()(int stt, int tgt)",
            "    {",
            "        dist[stt] = 0;",
            "        vector<int> p(n, -1);",
            "",
            "        bool has_negative_circuit = belf(p);",
            "        if (has_negative_circuit)",
            "        {",
            "            belf(p, true);",
            "        }",
            "",
            "        if (!this->is_inf(tgt))",
            "        {",
            "            for (int i = tgt; i != -1; i = p[i])",
            "            {",
            "                path.push_back(i);",
            "            }",
            "            reverse(path.begin(), path.end());",
            "        }",
            "",
            "        return has_negative_circuit;",
            "    }",
            "};\n",
        ],
        "description": "pFF"
    },
    "pTPS": {
        "prefix": "pTPS",
        "body": [
            "#ifndef __TPS__",
            "#define __TPS__",
            "typedef class TPS tps;",
            "class TPS",
            "{",
            "public:",
            "    TPS(){};",
            "    vector<int> operator()(ff &g)",
            "    {",
            "        int n = g.sz;",
            "        vector<int> indegree(n, 0), ret;",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            for (auto &ed : g[i])",
            "            {",
            "                indegree[ed.t]++;",
            "            }",
            "        }",
            "        queue<int> q;",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            if (indegree[i] == 0)",
            "            {",
            "                q.push(i);",
            "            }",
            "        }",
            "        while (!q.empty())",
            "        {",
            "            int now = q.front();",
            "            ret.push_back(now);",
            "            q.pop();",
            "            for (auto &ed : g[now])",
            "            {",
            "                indegree[ed.t]--;",
            "                if (indegree[ed.t] == 0)",
            "                {",
            "                    q.push(ed.t);",
            "                }",
            "            }",
            "        }",
            "        return ret;",
            "    }",
            "};",
            "#endif // __TPS__",
        ],
        "description": ""
    },
    "pROTATE": {
        "prefix": "pROTATE",
        "body": [
            "#ifndef __Pnt__",
            "#define __Pnt__",
            "typedef class Pnt pnt;",
            "class Pnt",
            "{",
            "public:",
            "    double x, y;",
            "",
            "    Pnt(const double &X, const double &Y) : x(X), y(Y){};",
            "",
            "    pnt plc(const pnt &p)",
            "    {",
            "        x = p.x;",
            "        y = p.y;",
            "        return *this;",
            "    }",
            "    pnt mv(const pnt &p)",
            "    {",
            "        return pnt(x - p.x, y - p.y);",
            "    }",
            "",
            "    double len()",
            "    {",
            "        return sqrt(x * x + y * y);",
            "    }",
            "    pnt rotate(double &th)",
            "    {",
            "        double rad = th / 180 * acos(-1);",
            "        return pnt(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad));",
            "    }",
            "",
            "    void print()",
            "    {",
            "        printf(\"%.9lf %.9lf\\n\", x, y);",
            "    }",
            "};",
            "#endif // __Pnt__\n",
        ],
        "description": ""
    },
    "pUF": {
        "prefix": "pUF",
        "body": [
            "class UF",
            "{",
            "private:",
            "    int n, N;",
            "    vector<int> par;",
            "    int root(int x)",
            "    {",
            "        return (par[x] < 0 ? x : par[x] = root(par[x]));",
            "    }",
            "",
            "public:",
            "    UF(int sz) : n(sz), N(sz)",
            "    {",
            "        par.resize(n, -1);",
            "    }",
            "    int size(int x)",
            "    {",
            "        return -par[root(x)];",
            "    }",
            "    int grp_size()",
            "    {",
            "        return N;",
            "    }",
            "    bool is_same(int x, int y)",
            "    {",
            "        return root(x) == root(y);",
            "    }",
            "    void unite(int x, int y)",
            "    {",
            "        x = root(x);",
            "        y = root(y);",
            "        if (is_same(x, y))",
            "        {",
            "            return;",
            "        }",
            "",
            "        if (size(x) < size(y))",
            "        {",
            "            swap(x, y);",
            "        }",
            "        par[x] += par[y];",
            "        par[y] = x;",
            "        N--;",
            "    }",
            "",
            "    int operator[](int x)",
            "    {",
            "        return root(x);",
            "    }",
            "};\n",
        ],
        "description": ""
    },
    "pDAY": {
        "prefix": "pDAY",
        "body": [
            "// DAY",
            "typedef class DAY DAY;",
            "class DAY",
            "{",
            "private:",
            "    const long long int y_400 = 97;",
            "    vector<int> y_1{-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};",
            "    vector<string> dow{\"sun\", \"mon\", \"tues\", \"wednes\", \"thurs\", \"fri\", \"satur\"};",
            "",
            "    // この年の元旦から1_indexed に直す",
            "    // ex) 1,1 -> 1日",
            "    long long int this_year(long long int y, long long int m, long long int d)",
            "    {",
            "        long long int res = y_1[m] + d;",
            "",
            "        // ３月が始まっていたら閏年かどうかも考える",
            "        if (3 <= m && is_uru(y))",
            "        {",
            "            res++;",
            "        }",
            "",
            "        return res;",
            "    }\n",
            "public:",
            "    bool is_uru(int year)",
            "    {",
            "        if (year % 400 == 0)",
            "        {",
            "            return true;",
            "        }",
            "        if (year % 100 == 0)",
            "        {",
            "            return false;",
            "        }\n",
            "        return (year % 4 == 0);",
            "    }\n",
            "    // 西暦1 年1 月1 日から1_indexed に直す",
            "    // ex) 1,1,1 -> 1",
            "    long long int days(long long int y, long long int m, long long int d)",
            "    {",
            "        long long int res = this_year(y, m, d) + (--y) * 365;\n",
            "        // 400 年単位で計算する 閏年は400年に97回存在する",
            "        res += (y / 400) * y_400;",
            "        y %= 400;\n",
            "        // 閏年は少なくとも4 の倍数の年",
            "        for (int i = 4; i <= y; i += 4)",
            "        {",
            "            if (is_uru(i))",
            "            {",
            "                res++;",
            "            }",
            "        }\n",
            "        return res;",
            "    }\n",
            "    // 1_indexed なカレンダー上でnum 番目にある日付を計算する",
            "    // ex) 1 -> 1/1/1",
            "    void _days(long long int num, long long int &y, long long int &m, long long int &d)",
            "    {",
            "        y = m = d = 0;\n",
            "        y = num / (400 * 365 + y_400) * 400;",
            "        // y 年の年末までを考えたとき、400年単位で考えてあとnum%y_400 日経過すればよい",
            "        num %= (400 * 365 + y_400);\n",
            "        long long int y_from_400 = num / 365;",
            "        y += y_from_400;\n",
            "        num %= 365;",
            "        // 400 年単位以降の閏年を考慮しないならば、y 年の年末の時点からあとnum 日経過すればよい\n",
            "        for (int i = 4; i <= y_from_400; i += 4)",
            "        {",
            "            if (is_uru(i))",
            "            {",
            "                num--;",
            "            }",
            "        }\n",
            "        // 400 年単位以降の閏年を考慮した結果、y 年の年末の時点からあとnum 日経過するか、戻ればよい",
            "        // 戻る際はy-1 年までの年末を考えて、足し算していく(num==0 のときはｙ年の年末を指している)",
            "        if (num <= 0)",
            "        {",
            "            num += 365;",
            "            if (is_uru(y))",
            "            {",
            "                num++;",
            "            }",
            "        }",
            "        else",
            "        {",
            "            y++;",
            "        }\n",
            "        // この段階でy は決定している",
            "        while (y_1[m + 1] < num)",
            "        {",
            "            m++;",
            "            if (m == 3 && is_uru(y))",
            "            {",
            "                num--;",
            "            }",
            "        }\n",
            "        d = num - y_1[m];",
            "    }\n",
            "    int _day_of_week(long long int y, long long int m, long long int d)",
            "    {",
            "        return days(y, m, d) % 7;",
            "    }\n",
            "    string day_of_week(long long int y, long long int m, long long int d)",
            "    {",
            "        return dow[_day_of_week(y, m, d)] + \"day\";",
            "    }",
            "};\n",
        ],
        "description": ""
    },
    "pNTT": {
        "prefix": "pNTT",
        "body": [
            "typedef class NTT NTT;",
            "class NTT",
            "{",
            "private:",
            "    char _char(long long int x)",
            "    {",
            "        if (x < 10)",
            "        {",
            "            return x + '0';",
            "        }\n",
            "        return x - 10 + 'a';",
            "    }",
            "    long long int _ll(char c)",
            "    {",
            "        if ('0' <= c && c <= '9')",
            "        {",
            "            return c - '0';",
            "        }\n",
            "        return c - 'a' + 10;",
            "    }\n",
            "public:",
            "    // 10進数でのlong long int 型数値に変換する",
            "    long long int to_10(const string &x, long long int from)",
            "    {",
            "        return stol(cng(x, from, 10));",
            "    }\n",
            "    string cng(const string &x, long long int from, long long int to)",
            "    {",
            "        long long int y = 0, z = 1;",
            "        string res = \"\";\n",
            "        for (int i = sz(x) - 1; 0 <= i; i--)",
            "        {",
            "            y += z * _ll(x[i]);",
            "            z *= from;",
            "        }",
            "        while (y)",
            "        {",
            "            res = _char(y % to) + res;",
            "            y /= to;",
            "        }\n",
            "        return res;",
            "    }\n",
            "    string erase_0(const string &s)",
            "    {",
            "        rep(i, 0, sz(s))",
            "        {",
            "            if (s[i] != '0')",
            "            {",
            "                return s.substr(i, sz(s));",
            "            }",
            "        }\n",
            "        return \"0\";",
            "    }",
            "};\n",
        ],
        "description": ""
    },
    "pSEG": {
        "prefix": "pSEG",
        "body": [
            "template <class T>",
            "class SEG",
            "{",
            "    int sz_vec = 1; // 基準配列のサイズを超える最小の2 のべき乗",
            "    T base;            // 配列の初期値",
            "    vector<T> dat;",
            "    int btm(int i)",
            "    {",
            "        return i + sz_vec - 1;",
            "    }",
            "    int l_chi(int i)",
            "    {",
            "        return i * 2 + 1;",
            "    }",
            "    int r_chi(int i)",
            "    {",
            "        return i * 2 + 2;",
            "    }",
            "",
            "    // 変更を親にむけて伝播させる",
            "    void influence(int i)",
            "    {",
            "        while (i)",
            "        {",
            "            int par = (i - 1) / 2;",
            "            int chi = (i & 1 ? i + 1 : i - 1);",
            "            dat[par] = func_seg(dat[i], dat[chi]);",
            "            i = par;",
            "        }",
            "    }",
            "",
            "public:",
            "    SEG(const vector<T> &v, long long int BASE) : base(BASE)",
            "    {",
            "        while (sz_vec < sz(v))",
            "        {",
            "            sz_vec <<= 1;",
            "        }",
            "        dat.resize(sz_vec * 2 - 1, base);",
            "",
            "        for (int i = 0; i < sz(v); i++)",
            "        {",
            "            dat[btm(i)] = v[i];",
            "        }",
            "        for (int ri = btm(0) - 1; ri >= 0; ri--)",
            "        {",
            "            dat[ri] = func_seg(dat[l_chi(ri)], dat[r_chi(ri)]);",
            "        }",
            "    }",
            "",
            "    void set(int i, long long int x)",
            "    {",
            "        dat[btm(i)] = x;",
            "        influence(btm(i));",
            "    }",
            "    void add(int i, long long int x)",
            "    {",
            "        dat[btm(i)] = func_seg(dat[btm(i)], x);",
            "        influence(btm(i));",
            "    }",
            "    T operator()(int a, int b, int now = 0, int l = 0)",
            "    {",
            "        return this->operator()(a, b, 0, 0, sz_vec);",
            "    }",
            "    T operator()(int a, int b, int now, int l, int r)",
            "    {",
            "        if (a <= l && r <= b)",
            "        {",
            "            return dat[now];",
            "        }",
            "        if (r <= a || b <= l)",
            "        {",
            "            return base;",
            "        }",
            "        return func_seg(this->operator()(a, b, l_chi(now), l, (l + r) / 2), this->operator()(a, b, r_chi(now), (l + r) / 2, r));",
            "    }",
            "",
            "    inline T &operator[](int i)",
            "    {",
            "        return dat[btm(i)];",
            "    }",
            "",
            "    void print()",
            "    {",
            "        int now = 2;",
            "        for (int i = 0; i < sz(dat); i++)",
            "        {",
            "            cout << dat[i] << \",\";",
            "            if (bitset<32>(now++).count() == 1)",
            "            {",
            "                cout << endl;",
            "            }",
            "        }",
            "    }",
            "    T func_seg(T l, T r)",
            "    {",
            "        return $0;",
            "    }",
            "};\n",
        ],
        "description": ""
    },
    "pLSG": {
        "prefix": "pLSG",
        "body": [
            "template <typename T>",
            "class datval",
            "{",
            "    T _val;",
            "    T _lazy;",
            "",
            "public:",
            "    bool is_reflected = false;",
            "    datval(T base) : _lazy(base){};",
            "",
            "    T lazy()",
            "    {",
            "        return _lazy;",
            "    }",
            "    T lazy(T x)",
            "    {",
            "        is_reflected = false;",
            "        return _lazy = x;",
            "    }",
            "    T val()",
            "    {",
            "        if (is_reflected == false)",
            "        {",
            "            return val(_lazy);",
            "        }",
            "        return _val;",
            "    }",
            "    T val(T x)",
            "    {",
            "        is_reflected = true;",
            "        return _val = x;",
            "    }",
            "};",
            "",
            "template <class T>",
            "class LSG",
            "{",
            "    int sz_vec = 1; // 基準配列のサイズを超える最小の2 のべき乗",
            "    T base;         // 配列の初期値",
            "",
            "    int l_chi(int i)",
            "    {",
            "        return i * 2 + 1;",
            "    }",
            "    int r_chi(int i)",
            "    {",
            "        return i * 2 + 2;",
            "    }",
            "",
            "public:",
            "    vector<datval<T>> dat;",
            "    LSG(const vector<T> &v, T BASE) : base(BASE)",
            "    {",
            "        while (sz_vec < sz(v))",
            "        {",
            "            sz_vec <<= 1;",
            "        }",
            "        dat.resize(sz_vec * 2 - 1, base);",
            "",
            "        int now = sz_vec - 1 + sz(v);",
            "        while (now--)",
            "        {",
            "            int i = now - sz_vec + 1;",
            "            (i < 0 ? dat[now].val(func(dat[l_chi(now)].val(), dat[r_chi(now)].val())) : dat[now].lazy(v[i]));",
            "        }",
            "    }",
            "",
            "    void eval(int now)",
            "    {",
            "        if (dat[now].is_reflected == true)",
            "        {",
            "            return;",
            "        }",
            "        if (now < sz_vec - 1)",
            "        {",
            "            dat[r_chi(now)].lazy(dat[l_chi(now)].lazy((dat[now].lazy())));",
            "        }",
            "        dat[now].val();",
            "    }",
            "",
            "    void update(int a, int b, T x, int now, int l, int r)",
            "    {",
            "        eval(now);",
            "        if (a <= l && r <= b)",
            "        {",
            "            dat[now].lazy(x);",
            "            eval(now);",
            "        }",
            "        else if (a < r && l < b)",
            "        {",
            "            update(a, b, x, l_chi(now), l, (l + r) / 2);",
            "            update(a, b, x, r_chi(now), (l + r) / 2, r);",
            "            dat[now].val(func(dat[l_chi(now)].val(), dat[r_chi(now)].val()));",
            "        }",
            "    }",
            "    void update(int a, int b, T x, int now = 0, int l = 0)",
            "    {",
            "        update(a, b, x, now, l, sz_vec);",
            "    }",
            "",
            "    T operator()(int a, int b, int now, int l, int r)",
            "    {",
            "        eval(now);",
            "        if (r <= a || b <= l)",
            "        {",
            "            return base;",
            "        }",
            "        else if (a <= l && r <= b)",
            "        {",
            "            return dat[now].val();",
            "        }",
            "        else",
            "        {",
            "            return func(this->operator()(a, b, l_chi(now), l, (l + r) / 2), this->operator()(a, b, r_chi(now), (l + r) / 2, r));",
            "        }",
            "    }",
            "    T operator()(int a, int b, int now = 0, int l = 0)",
            "    {",
            "        return this->operator()(a, b, 0, 0, sz_vec);",
            "    }",
            "",
            "    inline T operator[](int i) { return this->operator()(i, i + 1, 0, 0, sz_vec); }",
            "    void print()",
            "    {",
            "        int now = 2;",
            "        for (auto &dv : dat)",
            "        {",
            "            cout << dv.val() << \",\";",
            "            if (bitset<32>(now++).count() == 1)",
            "            {",
            "                cout << endl;",
            "            }",
            "        }",
            "    }",
            "    T func(T l, T r)",
            "    {",
            "        return $0;",
            "    }",
            "};\n",
        ],
        "description": ""
    },
    "pPRIME": {
        "prefix": "pPRIME",
        "body": [
            "class factor",
            "{",
            "public:",
            "    int prime, exponent;",
            "    factor(int x, int y) : prime(x), exponent(y){};",
            "    void print()",
            "    {",
            "        printf(\"%6d ^ %6d\\n\", prime, exponent);",
            "    }",
            "};",
            "",
            "class prm",
            "{",
            "public:",
            "    vector<int> erat;",
            "    int siz;",
            "    vector<int> prime;",
            "    map<int, vector<factor>> prime_map;",
            "    prm(int upper_limit) : siz(upper_limit + 1)",
            "    {",
            "        if (siz > 1e8)",
            "        {",
            "            et(\"too big\");",
            "        }",
            "",
            "        erat.resize(siz, 1);",
            "        erat[0] = erat[1] = 0;",
            "        for (int i = 2; i < siz; i++)",
            "        {",
            "            if (erat[i] == 0)",
            "            {",
            "                continue;",
            "            }",
            "",
            "            prime.push_back(i);",
            "            for (int j = (i << 1); j < siz; j += i)",
            "            {",
            "                erat[j] = 0;",
            "            }",
            "        }",
            "    }",
            "",
            "    bool is_prime(int x)",
            "    {",
            "        return x = *upper_bound(prime.begin(), prime.end(), x);",
            "    }",
            "",
            "    vector<factor> operator[](int x)",
            "    {",
            "        auto res = prime_map[x];",
            "        if (sz(res) == 0)",
            "        {",
            "            for (auto &pm : prime)",
            "            {",
            "                int tms = 0;",
            "                while (x % pm == 0)",
            "                {",
            "                    x /= pm;",
            "                    tms++;",
            "                }",
            "                if (tms)",
            "                {",
            "                    res.push_back(factor(pm, tms));",
            "                }",
            "                if (x == 1)",
            "                {",
            "                    break;",
            "                }",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};\n",
        ],
        "description": ""
    },
    "pCLCL": {
        "prefix": "pCLCL",
        "body": [
            "class CLCL",
            "{",
            "    using T = long long int;",
            "    vector<T> tails;",
            "    vector<T> cycle;",
            "",
            "public:",
            "    long long int tail, period;",
            "    CLCL(T x)",
            "    {",
            "        map<T, int> mp;",
            "        int odr = 0;",
            "        while (!mp.count(x))",
            "        {",
            "            mp[x] = odr++;",
            "            x = func(x);",
            "        }",
            "        tail = mp[x];",
            "        period = odr - tail;",
            "",
            "        tails.resize(tail);",
            "        cycle.resize(period);",
            "        for (auto &x : mp)",
            "        {",
            "            if (x.second < tail)",
            "            {",
            "                tails[x.second] = x.first;",
            "            }",
            "            else",
            "            {",
            "                cycle[x.second - tail] = x.first;",
            "            }",
            "        }",
            "    }",
            "    T operator[](int i)",
            "    {",
            "        return cycle.at(i);",
            "    }",
            "    // tms 回操作を繰り返した際の初期値の変化後の値",
            "    T operator()(long long int tms)",
            "    {",
            "        if (tms < tail)",
            "        {",
            "            return tails[tms];",
            "        }",
            "        tms -= tail;",
            "        tms %= period;",
            "        return cycle[tms];",
            "    }",
            "",
            "    T func(T x)",
            "    {",
            "        $0",
            "    }",
            "};\n",
        ],
        "description": ""
    },
}